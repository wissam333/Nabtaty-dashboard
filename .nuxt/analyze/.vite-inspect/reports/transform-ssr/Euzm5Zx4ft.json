{
  "resolvedId": "D:/Projects/Nabtaty-dashboard-de3bd56d6663c71275c3f076b188500fce6955c7/node_modules/vuetify/lib/components/VSlider/slider.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/* eslint-disable max-statements */\n// Composables\nimport { makeElevationProps } from \"../../composables/elevation.mjs\";\nimport { useRtl } from \"../../composables/locale.mjs\";\nimport { makeRoundedProps } from \"../../composables/rounded.mjs\"; // Utilities\nimport { computed, provide, ref, shallowRef, toRef } from 'vue';\nimport { clamp, createRange, getDecimals, propsFactory } from \"../../util/index.mjs\"; // Types\nexport const VSliderSymbol = Symbol.for('vuetify:v-slider');\nexport function getOffset(e, el, direction) {\n  const vertical = direction === 'vertical';\n  const rect = el.getBoundingClientRect();\n  const touch = 'touches' in e ? e.touches[0] : e;\n  return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);\n}\nfunction getPosition(e, position) {\n  if ('touches' in e && e.touches.length) return e.touches[0][position];else if ('changedTouches' in e && e.changedTouches.length) return e.changedTouches[0][position];else return e[position];\n}\nexport const makeSliderProps = propsFactory({\n  disabled: {\n    type: Boolean,\n    default: null\n  },\n  error: Boolean,\n  readonly: {\n    type: Boolean,\n    default: null\n  },\n  max: {\n    type: [Number, String],\n    default: 100\n  },\n  min: {\n    type: [Number, String],\n    default: 0\n  },\n  step: {\n    type: [Number, String],\n    default: 0\n  },\n  thumbColor: String,\n  thumbLabel: {\n    type: [Boolean, String],\n    default: undefined,\n    validator: v => typeof v === 'boolean' || v === 'always'\n  },\n  thumbSize: {\n    type: [Number, String],\n    default: 20\n  },\n  showTicks: {\n    type: [Boolean, String],\n    default: false,\n    validator: v => typeof v === 'boolean' || v === 'always'\n  },\n  ticks: {\n    type: [Array, Object]\n  },\n  tickSize: {\n    type: [Number, String],\n    default: 2\n  },\n  color: String,\n  trackColor: String,\n  trackFillColor: String,\n  trackSize: {\n    type: [Number, String],\n    default: 4\n  },\n  direction: {\n    type: String,\n    default: 'horizontal',\n    validator: v => ['vertical', 'horizontal'].includes(v)\n  },\n  reverse: Boolean,\n  ...makeRoundedProps(),\n  ...makeElevationProps({\n    elevation: 2\n  }),\n  ripple: {\n    type: Boolean,\n    default: true\n  }\n}, 'Slider');\nexport const useSteps = props => {\n  const min = computed(() => parseFloat(props.min));\n  const max = computed(() => parseFloat(props.max));\n  const step = computed(() => +props.step > 0 ? parseFloat(props.step) : 0);\n  const decimals = computed(() => Math.max(getDecimals(step.value), getDecimals(min.value)));\n  function roundValue(value) {\n    value = parseFloat(value);\n    if (step.value <= 0) return value;\n    const clamped = clamp(value, min.value, max.value);\n    const offset = min.value % step.value;\n    const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;\n    return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));\n  }\n  return {\n    min,\n    max,\n    step,\n    decimals,\n    roundValue\n  };\n};\nexport const useSlider = _ref => {\n  let {\n    props,\n    steps,\n    onSliderStart,\n    onSliderMove,\n    onSliderEnd,\n    getActiveThumb\n  } = _ref;\n  const {\n    isRtl\n  } = useRtl();\n  const isReversed = toRef(props, 'reverse');\n  const vertical = computed(() => props.direction === 'vertical');\n  const indexFromEnd = computed(() => vertical.value !== isReversed.value);\n  const {\n    min,\n    max,\n    step,\n    decimals,\n    roundValue\n  } = steps;\n  const thumbSize = computed(() => parseInt(props.thumbSize, 10));\n  const tickSize = computed(() => parseInt(props.tickSize, 10));\n  const trackSize = computed(() => parseInt(props.trackSize, 10));\n  const numTicks = computed(() => (max.value - min.value) / step.value);\n  const disabled = toRef(props, 'disabled');\n  const thumbColor = computed(() => props.error || props.disabled ? undefined : props.thumbColor ?? props.color);\n  const trackColor = computed(() => props.error || props.disabled ? undefined : props.trackColor ?? props.color);\n  const trackFillColor = computed(() => props.error || props.disabled ? undefined : props.trackFillColor ?? props.color);\n  const mousePressed = shallowRef(false);\n  const startOffset = shallowRef(0);\n  const trackContainerRef = ref();\n  const activeThumbRef = ref();\n  function parseMouseMove(e) {\n    const vertical = props.direction === 'vertical';\n    const start = vertical ? 'top' : 'left';\n    const length = vertical ? 'height' : 'width';\n    const position = vertical ? 'clientY' : 'clientX';\n    const {\n      [start]: trackStart,\n      [length]: trackLength\n    } = trackContainerRef.value?.$el.getBoundingClientRect();\n    const clickOffset = getPosition(e, position);\n\n    // It is possible for left to be NaN, force to number\n    let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;\n    if (vertical ? indexFromEnd.value : indexFromEnd.value !== isRtl.value) clickPos = 1 - clickPos;\n    return roundValue(min.value + clickPos * (max.value - min.value));\n  }\n  const handleStop = e => {\n    onSliderEnd({\n      value: parseMouseMove(e)\n    });\n    mousePressed.value = false;\n    startOffset.value = 0;\n  };\n  const handleStart = e => {\n    activeThumbRef.value = getActiveThumb(e);\n    if (!activeThumbRef.value) return;\n    activeThumbRef.value.focus();\n    mousePressed.value = true;\n    if (activeThumbRef.value.contains(e.target)) {\n      startOffset.value = getOffset(e, activeThumbRef.value, props.direction);\n    } else {\n      startOffset.value = 0;\n      onSliderMove({\n        value: parseMouseMove(e)\n      });\n    }\n    onSliderStart({\n      value: parseMouseMove(e)\n    });\n  };\n  const moveListenerOptions = {\n    passive: true,\n    capture: true\n  };\n  function onMouseMove(e) {\n    onSliderMove({\n      value: parseMouseMove(e)\n    });\n  }\n  function onSliderMouseUp(e) {\n    e.stopPropagation();\n    e.preventDefault();\n    handleStop(e);\n    window.removeEventListener('mousemove', onMouseMove, moveListenerOptions);\n    window.removeEventListener('mouseup', onSliderMouseUp);\n  }\n  function onSliderTouchend(e) {\n    handleStop(e);\n    window.removeEventListener('touchmove', onMouseMove, moveListenerOptions);\n    e.target?.removeEventListener('touchend', onSliderTouchend);\n  }\n  function onSliderTouchstart(e) {\n    handleStart(e);\n    window.addEventListener('touchmove', onMouseMove, moveListenerOptions);\n    e.target?.addEventListener('touchend', onSliderTouchend, {\n      passive: false\n    });\n  }\n  function onSliderMousedown(e) {\n    e.preventDefault();\n    handleStart(e);\n    window.addEventListener('mousemove', onMouseMove, moveListenerOptions);\n    window.addEventListener('mouseup', onSliderMouseUp, {\n      passive: false\n    });\n  }\n  const position = val => {\n    const percentage = (val - min.value) / (max.value - min.value) * 100;\n    return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);\n  };\n  const showTicks = toRef(props, 'showTicks');\n  const parsedTicks = computed(() => {\n    if (!showTicks.value) return [];\n    if (!props.ticks) {\n      return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map(t => {\n        const value = min.value + t * step.value;\n        return {\n          value,\n          position: position(value)\n        };\n      }) : [];\n    }\n    if (Array.isArray(props.ticks)) return props.ticks.map(t => ({\n      value: t,\n      position: position(t),\n      label: t.toString()\n    }));\n    return Object.keys(props.ticks).map(key => ({\n      value: parseFloat(key),\n      position: position(parseFloat(key)),\n      label: props.ticks[key]\n    }));\n  });\n  const hasLabels = computed(() => parsedTicks.value.some(_ref2 => {\n    let {\n      label\n    } = _ref2;\n    return !!label;\n  }));\n  const data = {\n    activeThumbRef,\n    color: toRef(props, 'color'),\n    decimals,\n    disabled,\n    direction: toRef(props, 'direction'),\n    elevation: toRef(props, 'elevation'),\n    hasLabels,\n    isReversed,\n    indexFromEnd,\n    min,\n    max,\n    mousePressed,\n    numTicks,\n    onSliderMousedown,\n    onSliderTouchstart,\n    parsedTicks,\n    parseMouseMove,\n    position,\n    readonly: toRef(props, 'readonly'),\n    rounded: toRef(props, 'rounded'),\n    roundValue,\n    showTicks,\n    startOffset,\n    step,\n    thumbSize,\n    thumbColor,\n    thumbLabel: toRef(props, 'thumbLabel'),\n    ticks: toRef(props, 'ticks'),\n    tickSize,\n    trackColor,\n    trackContainerRef,\n    trackFillColor,\n    trackSize,\n    vertical\n  };\n  provide(VSliderSymbol, data);\n  return data;\n};\n//# sourceMappingURL=slider.mjs.map",
      "start": 1731941050918,
      "end": 1731941051162,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1731941051162,
      "end": 1731941051162,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1731941051162,
      "end": 1731941051162,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1731941051162,
      "end": 1731941051162,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1731941051162,
      "end": 1731941051162,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1731941051162,
      "end": 1731941051163,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1731941051162,
      "end": 1731941051163,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941051163,
      "end": 1731941051163,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1731941051163,
      "end": 1731941051165,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { makeElevationProps } from \"../../composables/elevation.mjs\";\nimport { useRtl } from \"../../composables/locale.mjs\";\nimport { makeRoundedProps } from \"../../composables/rounded.mjs\";\nimport { computed, provide, ref, shallowRef, toRef } from \"vue\";\nimport { clamp, createRange, getDecimals, propsFactory } from \"../../util/index.mjs\";\nexport const VSliderSymbol = Symbol.for(\"vuetify:v-slider\");\nexport function getOffset(e, el, direction) {\n  const vertical = direction === \"vertical\";\n  const rect = el.getBoundingClientRect();\n  const touch = \"touches\" in e ? e.touches[0] : e;\n  return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);\n}\nfunction getPosition(e, position) {\n  if (\"touches\" in e && e.touches.length)\n    return e.touches[0][position];\n  else if (\"changedTouches\" in e && e.changedTouches.length)\n    return e.changedTouches[0][position];\n  else\n    return e[position];\n}\nexport const makeSliderProps = propsFactory({\n  disabled: {\n    type: Boolean,\n    default: null\n  },\n  error: Boolean,\n  readonly: {\n    type: Boolean,\n    default: null\n  },\n  max: {\n    type: [Number, String],\n    default: 100\n  },\n  min: {\n    type: [Number, String],\n    default: 0\n  },\n  step: {\n    type: [Number, String],\n    default: 0\n  },\n  thumbColor: String,\n  thumbLabel: {\n    type: [Boolean, String],\n    default: void 0,\n    validator: (v) => typeof v === \"boolean\" || v === \"always\"\n  },\n  thumbSize: {\n    type: [Number, String],\n    default: 20\n  },\n  showTicks: {\n    type: [Boolean, String],\n    default: false,\n    validator: (v) => typeof v === \"boolean\" || v === \"always\"\n  },\n  ticks: {\n    type: [Array, Object]\n  },\n  tickSize: {\n    type: [Number, String],\n    default: 2\n  },\n  color: String,\n  trackColor: String,\n  trackFillColor: String,\n  trackSize: {\n    type: [Number, String],\n    default: 4\n  },\n  direction: {\n    type: String,\n    default: \"horizontal\",\n    validator: (v) => [\"vertical\", \"horizontal\"].includes(v)\n  },\n  reverse: Boolean,\n  ...makeRoundedProps(),\n  ...makeElevationProps({\n    elevation: 2\n  }),\n  ripple: {\n    type: Boolean,\n    default: true\n  }\n}, \"Slider\");\nexport const useSteps = (props) => {\n  const min = computed(() => parseFloat(props.min));\n  const max = computed(() => parseFloat(props.max));\n  const step = computed(() => +props.step > 0 ? parseFloat(props.step) : 0);\n  const decimals = computed(() => Math.max(getDecimals(step.value), getDecimals(min.value)));\n  function roundValue(value) {\n    value = parseFloat(value);\n    if (step.value <= 0)\n      return value;\n    const clamped = clamp(value, min.value, max.value);\n    const offset = min.value % step.value;\n    const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;\n    return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));\n  }\n  return {\n    min,\n    max,\n    step,\n    decimals,\n    roundValue\n  };\n};\nexport const useSlider = (_ref) => {\n  let {\n    props,\n    steps,\n    onSliderStart,\n    onSliderMove,\n    onSliderEnd,\n    getActiveThumb\n  } = _ref;\n  const {\n    isRtl\n  } = useRtl();\n  const isReversed = toRef(props, \"reverse\");\n  const vertical = computed(() => props.direction === \"vertical\");\n  const indexFromEnd = computed(() => vertical.value !== isReversed.value);\n  const {\n    min,\n    max,\n    step,\n    decimals,\n    roundValue\n  } = steps;\n  const thumbSize = computed(() => parseInt(props.thumbSize, 10));\n  const tickSize = computed(() => parseInt(props.tickSize, 10));\n  const trackSize = computed(() => parseInt(props.trackSize, 10));\n  const numTicks = computed(() => (max.value - min.value) / step.value);\n  const disabled = toRef(props, \"disabled\");\n  const thumbColor = computed(() => props.error || props.disabled ? void 0 : props.thumbColor ?? props.color);\n  const trackColor = computed(() => props.error || props.disabled ? void 0 : props.trackColor ?? props.color);\n  const trackFillColor = computed(() => props.error || props.disabled ? void 0 : props.trackFillColor ?? props.color);\n  const mousePressed = shallowRef(false);\n  const startOffset = shallowRef(0);\n  const trackContainerRef = ref();\n  const activeThumbRef = ref();\n  function parseMouseMove(e) {\n    const vertical2 = props.direction === \"vertical\";\n    const start = vertical2 ? \"top\" : \"left\";\n    const length = vertical2 ? \"height\" : \"width\";\n    const position2 = vertical2 ? \"clientY\" : \"clientX\";\n    const {\n      [start]: trackStart,\n      [length]: trackLength\n    } = trackContainerRef.value?.$el.getBoundingClientRect();\n    const clickOffset = getPosition(e, position2);\n    let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;\n    if (vertical2 ? indexFromEnd.value : indexFromEnd.value !== isRtl.value)\n      clickPos = 1 - clickPos;\n    return roundValue(min.value + clickPos * (max.value - min.value));\n  }\n  const handleStop = (e) => {\n    onSliderEnd({\n      value: parseMouseMove(e)\n    });\n    mousePressed.value = false;\n    startOffset.value = 0;\n  };\n  const handleStart = (e) => {\n    activeThumbRef.value = getActiveThumb(e);\n    if (!activeThumbRef.value)\n      return;\n    activeThumbRef.value.focus();\n    mousePressed.value = true;\n    if (activeThumbRef.value.contains(e.target)) {\n      startOffset.value = getOffset(e, activeThumbRef.value, props.direction);\n    } else {\n      startOffset.value = 0;\n      onSliderMove({\n        value: parseMouseMove(e)\n      });\n    }\n    onSliderStart({\n      value: parseMouseMove(e)\n    });\n  };\n  const moveListenerOptions = {\n    passive: true,\n    capture: true\n  };\n  function onMouseMove(e) {\n    onSliderMove({\n      value: parseMouseMove(e)\n    });\n  }\n  function onSliderMouseUp(e) {\n    e.stopPropagation();\n    e.preventDefault();\n    handleStop(e);\n    (void 0).removeEventListener(\"mousemove\", onMouseMove, moveListenerOptions);\n    (void 0).removeEventListener(\"mouseup\", onSliderMouseUp);\n  }\n  function onSliderTouchend(e) {\n    handleStop(e);\n    (void 0).removeEventListener(\"touchmove\", onMouseMove, moveListenerOptions);\n    e.target?.removeEventListener(\"touchend\", onSliderTouchend);\n  }\n  function onSliderTouchstart(e) {\n    handleStart(e);\n    (void 0).addEventListener(\"touchmove\", onMouseMove, moveListenerOptions);\n    e.target?.addEventListener(\"touchend\", onSliderTouchend, {\n      passive: false\n    });\n  }\n  function onSliderMousedown(e) {\n    e.preventDefault();\n    handleStart(e);\n    (void 0).addEventListener(\"mousemove\", onMouseMove, moveListenerOptions);\n    (void 0).addEventListener(\"mouseup\", onSliderMouseUp, {\n      passive: false\n    });\n  }\n  const position = (val) => {\n    const percentage = (val - min.value) / (max.value - min.value) * 100;\n    return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);\n  };\n  const showTicks = toRef(props, \"showTicks\");\n  const parsedTicks = computed(() => {\n    if (!showTicks.value)\n      return [];\n    if (!props.ticks) {\n      return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map((t) => {\n        const value = min.value + t * step.value;\n        return {\n          value,\n          position: position(value)\n        };\n      }) : [];\n    }\n    if (Array.isArray(props.ticks))\n      return props.ticks.map((t) => ({\n        value: t,\n        position: position(t),\n        label: t.toString()\n      }));\n    return Object.keys(props.ticks).map((key) => ({\n      value: parseFloat(key),\n      position: position(parseFloat(key)),\n      label: props.ticks[key]\n    }));\n  });\n  const hasLabels = computed(() => parsedTicks.value.some((_ref2) => {\n    let {\n      label\n    } = _ref2;\n    return !!label;\n  }));\n  const data = {\n    activeThumbRef,\n    color: toRef(props, \"color\"),\n    decimals,\n    disabled,\n    direction: toRef(props, \"direction\"),\n    elevation: toRef(props, \"elevation\"),\n    hasLabels,\n    isReversed,\n    indexFromEnd,\n    min,\n    max,\n    mousePressed,\n    numTicks,\n    onSliderMousedown,\n    onSliderTouchstart,\n    parsedTicks,\n    parseMouseMove,\n    position,\n    readonly: toRef(props, \"readonly\"),\n    rounded: toRef(props, \"rounded\"),\n    roundValue,\n    showTicks,\n    startOffset,\n    step,\n    thumbSize,\n    thumbColor,\n    thumbLabel: toRef(props, \"thumbLabel\"),\n    ticks: toRef(props, \"ticks\"),\n    tickSize,\n    trackColor,\n    trackContainerRef,\n    trackFillColor,\n    trackSize,\n    vertical\n  };\n  provide(VSliderSymbol, data);\n  return data;\n};\n",
      "start": 1731941051165,
      "end": 1731941051226,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"D:/Projects/Nabtaty-dashboard-de3bd56d6663c71275c3f076b188500fce6955c7/node_modules/vuetify/lib/components/VSlider/slider.mjs\"],\n  \"sourcesContent\": [\"/* eslint-disable max-statements */\\n// Composables\\nimport { makeElevationProps } from \\\"../../composables/elevation.mjs\\\";\\nimport { useRtl } from \\\"../../composables/locale.mjs\\\";\\nimport { makeRoundedProps } from \\\"../../composables/rounded.mjs\\\"; // Utilities\\nimport { computed, provide, ref, shallowRef, toRef } from 'vue';\\nimport { clamp, createRange, getDecimals, propsFactory } from \\\"../../util/index.mjs\\\"; // Types\\nexport const VSliderSymbol = Symbol.for('vuetify:v-slider');\\nexport function getOffset(e, el, direction) {\\n  const vertical = direction === 'vertical';\\n  const rect = el.getBoundingClientRect();\\n  const touch = 'touches' in e ? e.touches[0] : e;\\n  return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);\\n}\\nfunction getPosition(e, position) {\\n  if ('touches' in e && e.touches.length) return e.touches[0][position];else if ('changedTouches' in e && e.changedTouches.length) return e.changedTouches[0][position];else return e[position];\\n}\\nexport const makeSliderProps = propsFactory({\\n  disabled: {\\n    type: Boolean,\\n    default: null\\n  },\\n  error: Boolean,\\n  readonly: {\\n    type: Boolean,\\n    default: null\\n  },\\n  max: {\\n    type: [Number, String],\\n    default: 100\\n  },\\n  min: {\\n    type: [Number, String],\\n    default: 0\\n  },\\n  step: {\\n    type: [Number, String],\\n    default: 0\\n  },\\n  thumbColor: String,\\n  thumbLabel: {\\n    type: [Boolean, String],\\n    default: undefined,\\n    validator: v => typeof v === 'boolean' || v === 'always'\\n  },\\n  thumbSize: {\\n    type: [Number, String],\\n    default: 20\\n  },\\n  showTicks: {\\n    type: [Boolean, String],\\n    default: false,\\n    validator: v => typeof v === 'boolean' || v === 'always'\\n  },\\n  ticks: {\\n    type: [Array, Object]\\n  },\\n  tickSize: {\\n    type: [Number, String],\\n    default: 2\\n  },\\n  color: String,\\n  trackColor: String,\\n  trackFillColor: String,\\n  trackSize: {\\n    type: [Number, String],\\n    default: 4\\n  },\\n  direction: {\\n    type: String,\\n    default: 'horizontal',\\n    validator: v => ['vertical', 'horizontal'].includes(v)\\n  },\\n  reverse: Boolean,\\n  ...makeRoundedProps(),\\n  ...makeElevationProps({\\n    elevation: 2\\n  }),\\n  ripple: {\\n    type: Boolean,\\n    default: true\\n  }\\n}, 'Slider');\\nexport const useSteps = props => {\\n  const min = computed(() => parseFloat(props.min));\\n  const max = computed(() => parseFloat(props.max));\\n  const step = computed(() => +props.step > 0 ? parseFloat(props.step) : 0);\\n  const decimals = computed(() => Math.max(getDecimals(step.value), getDecimals(min.value)));\\n  function roundValue(value) {\\n    value = parseFloat(value);\\n    if (step.value <= 0) return value;\\n    const clamped = clamp(value, min.value, max.value);\\n    const offset = min.value % step.value;\\n    const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;\\n    return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));\\n  }\\n  return {\\n    min,\\n    max,\\n    step,\\n    decimals,\\n    roundValue\\n  };\\n};\\nexport const useSlider = _ref => {\\n  let {\\n    props,\\n    steps,\\n    onSliderStart,\\n    onSliderMove,\\n    onSliderEnd,\\n    getActiveThumb\\n  } = _ref;\\n  const {\\n    isRtl\\n  } = useRtl();\\n  const isReversed = toRef(props, 'reverse');\\n  const vertical = computed(() => props.direction === 'vertical');\\n  const indexFromEnd = computed(() => vertical.value !== isReversed.value);\\n  const {\\n    min,\\n    max,\\n    step,\\n    decimals,\\n    roundValue\\n  } = steps;\\n  const thumbSize = computed(() => parseInt(props.thumbSize, 10));\\n  const tickSize = computed(() => parseInt(props.tickSize, 10));\\n  const trackSize = computed(() => parseInt(props.trackSize, 10));\\n  const numTicks = computed(() => (max.value - min.value) / step.value);\\n  const disabled = toRef(props, 'disabled');\\n  const thumbColor = computed(() => props.error || props.disabled ? undefined : props.thumbColor ?? props.color);\\n  const trackColor = computed(() => props.error || props.disabled ? undefined : props.trackColor ?? props.color);\\n  const trackFillColor = computed(() => props.error || props.disabled ? undefined : props.trackFillColor ?? props.color);\\n  const mousePressed = shallowRef(false);\\n  const startOffset = shallowRef(0);\\n  const trackContainerRef = ref();\\n  const activeThumbRef = ref();\\n  function parseMouseMove(e) {\\n    const vertical = props.direction === 'vertical';\\n    const start = vertical ? 'top' : 'left';\\n    const length = vertical ? 'height' : 'width';\\n    const position = vertical ? 'clientY' : 'clientX';\\n    const {\\n      [start]: trackStart,\\n      [length]: trackLength\\n    } = trackContainerRef.value?.$el.getBoundingClientRect();\\n    const clickOffset = getPosition(e, position);\\n\\n    // It is possible for left to be NaN, force to number\\n    let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;\\n    if (vertical ? indexFromEnd.value : indexFromEnd.value !== isRtl.value) clickPos = 1 - clickPos;\\n    return roundValue(min.value + clickPos * (max.value - min.value));\\n  }\\n  const handleStop = e => {\\n    onSliderEnd({\\n      value: parseMouseMove(e)\\n    });\\n    mousePressed.value = false;\\n    startOffset.value = 0;\\n  };\\n  const handleStart = e => {\\n    activeThumbRef.value = getActiveThumb(e);\\n    if (!activeThumbRef.value) return;\\n    activeThumbRef.value.focus();\\n    mousePressed.value = true;\\n    if (activeThumbRef.value.contains(e.target)) {\\n      startOffset.value = getOffset(e, activeThumbRef.value, props.direction);\\n    } else {\\n      startOffset.value = 0;\\n      onSliderMove({\\n        value: parseMouseMove(e)\\n      });\\n    }\\n    onSliderStart({\\n      value: parseMouseMove(e)\\n    });\\n  };\\n  const moveListenerOptions = {\\n    passive: true,\\n    capture: true\\n  };\\n  function onMouseMove(e) {\\n    onSliderMove({\\n      value: parseMouseMove(e)\\n    });\\n  }\\n  function onSliderMouseUp(e) {\\n    e.stopPropagation();\\n    e.preventDefault();\\n    handleStop(e);\\n    window.removeEventListener('mousemove', onMouseMove, moveListenerOptions);\\n    window.removeEventListener('mouseup', onSliderMouseUp);\\n  }\\n  function onSliderTouchend(e) {\\n    handleStop(e);\\n    window.removeEventListener('touchmove', onMouseMove, moveListenerOptions);\\n    e.target?.removeEventListener('touchend', onSliderTouchend);\\n  }\\n  function onSliderTouchstart(e) {\\n    handleStart(e);\\n    window.addEventListener('touchmove', onMouseMove, moveListenerOptions);\\n    e.target?.addEventListener('touchend', onSliderTouchend, {\\n      passive: false\\n    });\\n  }\\n  function onSliderMousedown(e) {\\n    e.preventDefault();\\n    handleStart(e);\\n    window.addEventListener('mousemove', onMouseMove, moveListenerOptions);\\n    window.addEventListener('mouseup', onSliderMouseUp, {\\n      passive: false\\n    });\\n  }\\n  const position = val => {\\n    const percentage = (val - min.value) / (max.value - min.value) * 100;\\n    return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);\\n  };\\n  const showTicks = toRef(props, 'showTicks');\\n  const parsedTicks = computed(() => {\\n    if (!showTicks.value) return [];\\n    if (!props.ticks) {\\n      return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map(t => {\\n        const value = min.value + t * step.value;\\n        return {\\n          value,\\n          position: position(value)\\n        };\\n      }) : [];\\n    }\\n    if (Array.isArray(props.ticks)) return props.ticks.map(t => ({\\n      value: t,\\n      position: position(t),\\n      label: t.toString()\\n    }));\\n    return Object.keys(props.ticks).map(key => ({\\n      value: parseFloat(key),\\n      position: position(parseFloat(key)),\\n      label: props.ticks[key]\\n    }));\\n  });\\n  const hasLabels = computed(() => parsedTicks.value.some(_ref2 => {\\n    let {\\n      label\\n    } = _ref2;\\n    return !!label;\\n  }));\\n  const data = {\\n    activeThumbRef,\\n    color: toRef(props, 'color'),\\n    decimals,\\n    disabled,\\n    direction: toRef(props, 'direction'),\\n    elevation: toRef(props, 'elevation'),\\n    hasLabels,\\n    isReversed,\\n    indexFromEnd,\\n    min,\\n    max,\\n    mousePressed,\\n    numTicks,\\n    onSliderMousedown,\\n    onSliderTouchstart,\\n    parsedTicks,\\n    parseMouseMove,\\n    position,\\n    readonly: toRef(props, 'readonly'),\\n    rounded: toRef(props, 'rounded'),\\n    roundValue,\\n    showTicks,\\n    startOffset,\\n    step,\\n    thumbSize,\\n    thumbColor,\\n    thumbLabel: toRef(props, 'thumbLabel'),\\n    ticks: toRef(props, 'ticks'),\\n    tickSize,\\n    trackColor,\\n    trackContainerRef,\\n    trackFillColor,\\n    trackSize,\\n    vertical\\n  };\\n  provide(VSliderSymbol, data);\\n  return data;\\n};\\n//# sourceMappingURL=slider.mjs.map\"],\n  \"mappings\": \"AAEA,SAAS,0BAA0B;AACnC,SAAS,cAAc;AACvB,SAAS,wBAAwB;AACjC,SAAS,UAAU,SAAS,KAAK,YAAY,aAAa;AAC1D,SAAS,OAAO,aAAa,aAAa,oBAAoB;AACvD,aAAM,gBAAgB,OAAO,IAAI,kBAAkB;AACnD,gBAAS,UAAU,GAAG,IAAI,WAAW;AAC1C,QAAM,WAAW,cAAc;AAC/B,QAAM,OAAO,GAAG,sBAAsB;AACtC,QAAM,QAAQ,aAAa,IAAI,EAAE,QAAQ,CAAC,IAAI;AAC9C,SAAO,WAAW,MAAM,WAAW,KAAK,MAAM,KAAK,SAAS,KAAK,MAAM,WAAW,KAAK,OAAO,KAAK,QAAQ;AAC7G;AACA,SAAS,YAAY,GAAG,UAAU;AAChC,MAAI,aAAa,KAAK,EAAE,QAAQ;AAAQ,WAAO,EAAE,QAAQ,CAAC,EAAE,QAAQ;AAAA,WAAW,oBAAoB,KAAK,EAAE,eAAe;AAAQ,WAAO,EAAE,eAAe,CAAC,EAAE,QAAQ;AAAA;AAAO,WAAO,EAAE,QAAQ;AAC9L;AACO,aAAM,kBAAkB,aAAa;AAAA,EAC1C,UAAU;AAAA,IACR,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AAAA,EACA,OAAO;AAAA,EACP,UAAU;AAAA,IACR,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AAAA,EACA,KAAK;AAAA,IACH,MAAM,CAAC,QAAQ,MAAM;AAAA,IACrB,SAAS;AAAA,EACX;AAAA,EACA,KAAK;AAAA,IACH,MAAM,CAAC,QAAQ,MAAM;AAAA,IACrB,SAAS;AAAA,EACX;AAAA,EACA,MAAM;AAAA,IACJ,MAAM,CAAC,QAAQ,MAAM;AAAA,IACrB,SAAS;AAAA,EACX;AAAA,EACA,YAAY;AAAA,EACZ,YAAY;AAAA,IACV,MAAM,CAAC,SAAS,MAAM;AAAA,IACtB,SAAS;AAAA,IACT,WAAW,OAAK,OAAO,MAAM,aAAa,MAAM;AAAA,EAClD;AAAA,EACA,WAAW;AAAA,IACT,MAAM,CAAC,QAAQ,MAAM;AAAA,IACrB,SAAS;AAAA,EACX;AAAA,EACA,WAAW;AAAA,IACT,MAAM,CAAC,SAAS,MAAM;AAAA,IACtB,SAAS;AAAA,IACT,WAAW,OAAK,OAAO,MAAM,aAAa,MAAM;AAAA,EAClD;AAAA,EACA,OAAO;AAAA,IACL,MAAM,CAAC,OAAO,MAAM;AAAA,EACtB;AAAA,EACA,UAAU;AAAA,IACR,MAAM,CAAC,QAAQ,MAAM;AAAA,IACrB,SAAS;AAAA,EACX;AAAA,EACA,OAAO;AAAA,EACP,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,WAAW;AAAA,IACT,MAAM,CAAC,QAAQ,MAAM;AAAA,IACrB,SAAS;AAAA,EACX;AAAA,EACA,WAAW;AAAA,IACT,MAAM;AAAA,IACN,SAAS;AAAA,IACT,WAAW,OAAK,CAAC,YAAY,YAAY,EAAE,SAAS,CAAC;AAAA,EACvD;AAAA,EACA,SAAS;AAAA,EACT,GAAG,iBAAiB;AAAA,EACpB,GAAG,mBAAmB;AAAA,IACpB,WAAW;AAAA,EACb,CAAC;AAAA,EACD,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AACF,GAAG,QAAQ;AACJ,aAAM,WAAW,WAAS;AAC/B,QAAM,MAAM,SAAS,MAAM,WAAW,MAAM,GAAG,CAAC;AAChD,QAAM,MAAM,SAAS,MAAM,WAAW,MAAM,GAAG,CAAC;AAChD,QAAM,OAAO,SAAS,MAAM,CAAC,MAAM,OAAO,IAAI,WAAW,MAAM,IAAI,IAAI,CAAC;AACxE,QAAM,WAAW,SAAS,MAAM,KAAK,IAAI,YAAY,KAAK,KAAK,GAAG,YAAY,IAAI,KAAK,CAAC,CAAC;AACzF,WAAS,WAAW,OAAO;AACzB,YAAQ,WAAW,KAAK;AACxB,QAAI,KAAK,SAAS;AAAG,aAAO;AAC5B,UAAM,UAAU,MAAM,OAAO,IAAI,OAAO,IAAI,KAAK;AACjD,UAAM,SAAS,IAAI,QAAQ,KAAK;AAChC,UAAM,WAAW,KAAK,OAAO,UAAU,UAAU,KAAK,KAAK,IAAI,KAAK,QAAQ;AAC5E,WAAO,WAAW,KAAK,IAAI,UAAU,IAAI,KAAK,EAAE,QAAQ,SAAS,KAAK,CAAC;AAAA,EACzE;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AACO,aAAM,YAAY,UAAQ;AAC/B,MAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM;AAAA,IACJ;AAAA,EACF,IAAI,OAAO;AACX,QAAM,aAAa,MAAM,OAAO,SAAS;AACzC,QAAM,WAAW,SAAS,MAAM,MAAM,cAAc,UAAU;AAC9D,QAAM,eAAe,SAAS,MAAM,SAAS,UAAU,WAAW,KAAK;AACvE,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,YAAY,SAAS,MAAM,SAAS,MAAM,WAAW,EAAE,CAAC;AAC9D,QAAM,WAAW,SAAS,MAAM,SAAS,MAAM,UAAU,EAAE,CAAC;AAC5D,QAAM,YAAY,SAAS,MAAM,SAAS,MAAM,WAAW,EAAE,CAAC;AAC9D,QAAM,WAAW,SAAS,OAAO,IAAI,QAAQ,IAAI,SAAS,KAAK,KAAK;AACpE,QAAM,WAAW,MAAM,OAAO,UAAU;AACxC,QAAM,aAAa,SAAS,MAAM,MAAM,SAAS,MAAM,WAAW,SAAY,MAAM,cAAc,MAAM,KAAK;AAC7G,QAAM,aAAa,SAAS,MAAM,MAAM,SAAS,MAAM,WAAW,SAAY,MAAM,cAAc,MAAM,KAAK;AAC7G,QAAM,iBAAiB,SAAS,MAAM,MAAM,SAAS,MAAM,WAAW,SAAY,MAAM,kBAAkB,MAAM,KAAK;AACrH,QAAM,eAAe,WAAW,KAAK;AACrC,QAAM,cAAc,WAAW,CAAC;AAChC,QAAM,oBAAoB,IAAI;AAC9B,QAAM,iBAAiB,IAAI;AAC3B,WAAS,eAAe,GAAG;AACzB,UAAMA,YAAW,MAAM,cAAc;AACrC,UAAM,QAAQA,YAAW,QAAQ;AACjC,UAAM,SAASA,YAAW,WAAW;AACrC,UAAMC,YAAWD,YAAW,YAAY;AACxC,UAAM;AAAA,MACJ,CAAC,KAAK,GAAG;AAAA,MACT,CAAC,MAAM,GAAG;AAAA,IACZ,IAAI,kBAAkB,OAAO,IAAI,sBAAsB;AACvD,UAAM,cAAc,YAAY,GAAGC,SAAQ;AAG3C,QAAI,WAAW,KAAK,IAAI,KAAK,KAAK,cAAc,aAAa,YAAY,SAAS,aAAa,CAAC,GAAG,CAAC,KAAK;AACzG,QAAID,YAAW,aAAa,QAAQ,aAAa,UAAU,MAAM;AAAO,iBAAW,IAAI;AACvF,WAAO,WAAW,IAAI,QAAQ,YAAY,IAAI,QAAQ,IAAI,MAAM;AAAA,EAClE;AACA,QAAM,aAAa,OAAK;AACtB,gBAAY;AAAA,MACV,OAAO,eAAe,CAAC;AAAA,IACzB,CAAC;AACD,iBAAa,QAAQ;AACrB,gBAAY,QAAQ;AAAA,EACtB;AACA,QAAM,cAAc,OAAK;AACvB,mBAAe,QAAQ,eAAe,CAAC;AACvC,QAAI,CAAC,eAAe;AAAO;AAC3B,mBAAe,MAAM,MAAM;AAC3B,iBAAa,QAAQ;AACrB,QAAI,eAAe,MAAM,SAAS,EAAE,MAAM,GAAG;AAC3C,kBAAY,QAAQ,UAAU,GAAG,eAAe,OAAO,MAAM,SAAS;AAAA,IACxE,OAAO;AACL,kBAAY,QAAQ;AACpB,mBAAa;AAAA,QACX,OAAO,eAAe,CAAC;AAAA,MACzB,CAAC;AAAA,IACH;AACA,kBAAc;AAAA,MACZ,OAAO,eAAe,CAAC;AAAA,IACzB,CAAC;AAAA,EACH;AACA,QAAM,sBAAsB;AAAA,IAC1B,SAAS;AAAA,IACT,SAAS;AAAA,EACX;AACA,WAAS,YAAY,GAAG;AACtB,iBAAa;AAAA,MACX,OAAO,eAAe,CAAC;AAAA,IACzB,CAAC;AAAA,EACH;AACA,WAAS,gBAAgB,GAAG;AAC1B,MAAE,gBAAgB;AAClB,MAAE,eAAe;AACjB,eAAW,CAAC;AACZ,aAAO,oBAAoB,aAAa,aAAa,mBAAmB;AACxE,aAAO,oBAAoB,WAAW,eAAe;AAAA,EACvD;AACA,WAAS,iBAAiB,GAAG;AAC3B,eAAW,CAAC;AACZ,aAAO,oBAAoB,aAAa,aAAa,mBAAmB;AACxE,MAAE,QAAQ,oBAAoB,YAAY,gBAAgB;AAAA,EAC5D;AACA,WAAS,mBAAmB,GAAG;AAC7B,gBAAY,CAAC;AACb,aAAO,iBAAiB,aAAa,aAAa,mBAAmB;AACrE,MAAE,QAAQ,iBAAiB,YAAY,kBAAkB;AAAA,MACvD,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACA,WAAS,kBAAkB,GAAG;AAC5B,MAAE,eAAe;AACjB,gBAAY,CAAC;AACb,aAAO,iBAAiB,aAAa,aAAa,mBAAmB;AACrE,aAAO,iBAAiB,WAAW,iBAAiB;AAAA,MAClD,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACA,QAAM,WAAW,SAAO;AACtB,UAAM,cAAc,MAAM,IAAI,UAAU,IAAI,QAAQ,IAAI,SAAS;AACjE,WAAO,MAAM,MAAM,UAAU,IAAI,IAAI,YAAY,GAAG,GAAG;AAAA,EACzD;AACA,QAAM,YAAY,MAAM,OAAO,WAAW;AAC1C,QAAM,cAAc,SAAS,MAAM;AACjC,QAAI,CAAC,UAAU;AAAO,aAAO,CAAC;AAC9B,QAAI,CAAC,MAAM,OAAO;AAChB,aAAO,SAAS,UAAU,WAAW,YAAY,SAAS,QAAQ,CAAC,EAAE,IAAI,OAAK;AAC5E,cAAM,QAAQ,IAAI,QAAQ,IAAI,KAAK;AACnC,eAAO;AAAA,UACL;AAAA,UACA,UAAU,SAAS,KAAK;AAAA,QAC1B;AAAA,MACF,CAAC,IAAI,CAAC;AAAA,IACR;AACA,QAAI,MAAM,QAAQ,MAAM,KAAK;AAAG,aAAO,MAAM,MAAM,IAAI,QAAM;AAAA,QAC3D,OAAO;AAAA,QACP,UAAU,SAAS,CAAC;AAAA,QACpB,OAAO,EAAE,SAAS;AAAA,MACpB,EAAE;AACF,WAAO,OAAO,KAAK,MAAM,KAAK,EAAE,IAAI,UAAQ;AAAA,MAC1C,OAAO,WAAW,GAAG;AAAA,MACrB,UAAU,SAAS,WAAW,GAAG,CAAC;AAAA,MAClC,OAAO,MAAM,MAAM,GAAG;AAAA,IACxB,EAAE;AAAA,EACJ,CAAC;AACD,QAAM,YAAY,SAAS,MAAM,YAAY,MAAM,KAAK,WAAS;AAC/D,QAAI;AAAA,MACF;AAAA,IACF,IAAI;AACJ,WAAO,CAAC,CAAC;AAAA,EACX,CAAC,CAAC;AACF,QAAM,OAAO;AAAA,IACX;AAAA,IACA,OAAO,MAAM,OAAO,OAAO;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,WAAW,MAAM,OAAO,WAAW;AAAA,IACnC,WAAW,MAAM,OAAO,WAAW;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,MAAM,OAAO,UAAU;AAAA,IACjC,SAAS,MAAM,OAAO,SAAS;AAAA,IAC/B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,YAAY,MAAM,OAAO,YAAY;AAAA,IACrC,OAAO,MAAM,OAAO,OAAO;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,UAAQ,eAAe,IAAI;AAC3B,SAAO;AACT;\",\n  \"names\": [\"vertical\", \"position\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1731941051226,
      "end": 1731941051226,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1731941051226,
      "end": 1731941051226,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1731941051226,
      "end": 1731941051226,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1731941051226,
      "end": 1731941051226,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1731941051226,
      "end": 1731941051226,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1731941051227,
      "end": 1731941051227,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1731941051228,
      "end": 1731941051228,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1731941051230,
      "end": 1731941051230,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1731941051230,
      "end": 1731941051230,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1731941051230,
      "end": 1731941051230,
      "order": "normal"
    }
  ]
}
