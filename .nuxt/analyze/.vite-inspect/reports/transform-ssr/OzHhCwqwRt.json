{
  "resolvedId": "D:/Projects/Nabtaty-dashboard-de3bd56d6663c71275c3f076b188500fce6955c7/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { createVNode as _createVNode } from \"vue\";\n// Styles\nimport \"./VSlideGroup.css\";\n\n// Components\nimport { VFadeTransition } from \"../transitions/index.mjs\";\nimport { VIcon } from \"../VIcon/index.mjs\"; // Composables\nimport { makeComponentProps } from \"../../composables/component.mjs\";\nimport { makeDisplayProps, useDisplay } from \"../../composables/display.mjs\";\nimport { makeGroupProps, useGroup } from \"../../composables/group.mjs\";\nimport { IconValue } from \"../../composables/icons.mjs\";\nimport { useRtl } from \"../../composables/locale.mjs\";\nimport { useResizeObserver } from \"../../composables/resizeObserver.mjs\";\nimport { makeTagProps } from \"../../composables/tag.mjs\"; // Utilities\nimport { computed, shallowRef, watch } from 'vue';\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from \"./helpers.mjs\";\nimport { clamp, focusableChildren, genericComponent, IN_BROWSER, propsFactory, useRender } from \"../../util/index.mjs\"; // Types\nexport const VSlideGroupSymbol = Symbol.for('vuetify:v-slide-group');\nexport const makeVSlideGroupProps = propsFactory({\n  centerActive: Boolean,\n  direction: {\n    type: String,\n    default: 'horizontal'\n  },\n  symbol: {\n    type: null,\n    default: VSlideGroupSymbol\n  },\n  nextIcon: {\n    type: IconValue,\n    default: '$next'\n  },\n  prevIcon: {\n    type: IconValue,\n    default: '$prev'\n  },\n  showArrows: {\n    type: [Boolean, String],\n    validator: v => typeof v === 'boolean' || ['always', 'desktop', 'mobile'].includes(v)\n  },\n  ...makeComponentProps(),\n  ...makeDisplayProps(),\n  ...makeTagProps(),\n  ...makeGroupProps({\n    selectedClass: 'v-slide-group-item--active'\n  })\n}, 'VSlideGroup');\nexport const VSlideGroup = genericComponent()({\n  name: 'VSlideGroup',\n  props: makeVSlideGroupProps(),\n  emits: {\n    'update:modelValue': value => true\n  },\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const {\n      isRtl\n    } = useRtl();\n    const {\n      displayClasses,\n      mobile\n    } = useDisplay(props);\n    const group = useGroup(props, props.symbol);\n    const isOverflowing = shallowRef(false);\n    const scrollOffset = shallowRef(0);\n    const containerSize = shallowRef(0);\n    const contentSize = shallowRef(0);\n    const isHorizontal = computed(() => props.direction === 'horizontal');\n    const {\n      resizeRef: containerRef,\n      contentRect: containerRect\n    } = useResizeObserver();\n    const {\n      resizeRef: contentRef,\n      contentRect\n    } = useResizeObserver();\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[0]);\n    });\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1]);\n    });\n    if (IN_BROWSER) {\n      let frame = -1;\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame);\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height';\n            containerSize.value = containerRect.value[sizeProperty];\n            contentSize.value = contentRect.value[sizeProperty];\n            isOverflowing.value = containerSize.value + 1 < contentSize.value;\n          }\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value];\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0;\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value\n              });\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value\n              });\n            }\n          }\n        });\n      });\n    }\n    const disableTransition = shallowRef(false);\n    let startTouch = 0;\n    let startOffset = 0;\n    function onTouchstart(e) {\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      startOffset = sign * scrollOffset.value;\n      startTouch = e.touches[0][sizeProperty];\n      disableTransition.value = true;\n    }\n    function onTouchmove(e) {\n      if (!isOverflowing.value) return;\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);\n    }\n    function onTouchend(e) {\n      const maxScrollOffset = contentSize.value - containerSize.value;\n      if (scrollOffset.value < 0 || !isOverflowing.value) {\n        scrollOffset.value = 0;\n      } else if (scrollOffset.value >= maxScrollOffset) {\n        scrollOffset.value = maxScrollOffset;\n      }\n      disableTransition.value = false;\n    }\n    function onScroll() {\n      if (!containerRef.value) return;\n      containerRef.value[isHorizontal.value ? 'scrollLeft' : 'scrollTop'] = 0;\n    }\n    const isFocused = shallowRef(false);\n    function onFocusin(e) {\n      isFocused.value = true;\n      if (!isOverflowing.value || !contentRef.value) return;\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value\n            });\n            return;\n          }\n        }\n      }\n    }\n    function onFocusout(e) {\n      isFocused.value = false;\n    }\n    function onFocus(e) {\n      if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget))) focus();\n    }\n    function onKeydown(e) {\n      if (!contentRef.value) return;\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          focus(isRtl.value ? 'prev' : 'next');\n        } else if (e.key === 'ArrowLeft') {\n          focus(isRtl.value ? 'next' : 'prev');\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          focus('next');\n        } else if (e.key === 'ArrowUp') {\n          focus('prev');\n        }\n      }\n      if (e.key === 'Home') {\n        focus('first');\n      } else if (e.key === 'End') {\n        focus('last');\n      }\n    }\n    function focus(location) {\n      if (!contentRef.value) return;\n      if (!location) {\n        const focusable = focusableChildren(contentRef.value);\n        focusable[0]?.focus();\n      } else if (location === 'next') {\n        const el = contentRef.value.querySelector(':focus')?.nextElementSibling;\n        if (el) el.focus();else focus('first');\n      } else if (location === 'prev') {\n        const el = contentRef.value.querySelector(':focus')?.previousElementSibling;\n        if (el) el.focus();else focus('last');\n      } else if (location === 'first') {\n        contentRef.value.firstElementChild?.focus();\n      } else if (location === 'last') {\n        contentRef.value.lastElementChild?.focus();\n      }\n    }\n    function scrollTo(location) {\n      const newAbsoluteOffset = scrollOffset.value + (location === 'prev' ? -1 : 1) * containerSize.value;\n      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);\n    }\n    const contentStyles = computed(() => {\n      // This adds friction when scrolling the 'wrong' way when at max offset\n      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;\n\n      // This adds friction when scrolling the 'wrong' way when at min offset\n      if (scrollOffset.value <= 0) {\n        scrollAmount = bias(-scrollOffset.value);\n      }\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      return {\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${sign * scrollAmount}px)`,\n        transition: disableTransition.value ? 'none' : '',\n        willChange: disableTransition.value ? 'transform' : ''\n      };\n    });\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected\n    }));\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always':\n          return true;\n\n        // Always show arrows on desktop\n        case 'desktop':\n          return !mobile.value;\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true:\n          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n\n        // Always show on mobile\n        case 'mobile':\n          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default:\n          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);\n      }\n    });\n    const hasPrev = computed(() => {\n      return Math.abs(scrollOffset.value) > 0;\n    });\n    const hasNext = computed(() => {\n      // Check one scroll ahead to know the width of right-most item\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;\n    });\n    useRender(() => _createVNode(props.tag, {\n      \"class\": ['v-slide-group', {\n        'v-slide-group--vertical': !isHorizontal.value,\n        'v-slide-group--has-affixes': hasAffixes.value,\n        'v-slide-group--is-overflowing': isOverflowing.value\n      }, displayClasses.value, props.class],\n      \"style\": props.style,\n      \"tabindex\": isFocused.value || group.selected.value.length ? -1 : 0,\n      \"onFocus\": onFocus\n    }, {\n      default: () => [hasAffixes.value && _createVNode(\"div\", {\n        \"key\": \"prev\",\n        \"class\": ['v-slide-group__prev', {\n          'v-slide-group__prev--disabled': !hasPrev.value\n        }],\n        \"onClick\": () => hasPrev.value && scrollTo('prev')\n      }, [slots.prev?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\n        default: () => [_createVNode(VIcon, {\n          \"icon\": isRtl.value ? props.nextIcon : props.prevIcon\n        }, null)]\n      })]), _createVNode(\"div\", {\n        \"key\": \"container\",\n        \"ref\": containerRef,\n        \"class\": \"v-slide-group__container\",\n        \"onScroll\": onScroll\n      }, [_createVNode(\"div\", {\n        \"ref\": contentRef,\n        \"class\": \"v-slide-group__content\",\n        \"style\": contentStyles.value,\n        \"onTouchstartPassive\": onTouchstart,\n        \"onTouchmovePassive\": onTouchmove,\n        \"onTouchendPassive\": onTouchend,\n        \"onFocusin\": onFocusin,\n        \"onFocusout\": onFocusout,\n        \"onKeydown\": onKeydown\n      }, [slots.default?.(slotProps.value)])]), hasAffixes.value && _createVNode(\"div\", {\n        \"key\": \"next\",\n        \"class\": ['v-slide-group__next', {\n          'v-slide-group__next--disabled': !hasNext.value\n        }],\n        \"onClick\": () => hasNext.value && scrollTo('next')\n      }, [slots.next?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\n        default: () => [_createVNode(VIcon, {\n          \"icon\": isRtl.value ? props.prevIcon : props.nextIcon\n        }, null)]\n      })])]\n    }));\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus\n    };\n  }\n});\n//# sourceMappingURL=VSlideGroup.mjs.map",
      "start": 1731941048133,
      "end": 1731941048380,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1731941048380,
      "end": 1731941048380,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1731941048380,
      "end": 1731941048380,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1731941048380,
      "end": 1731941048381,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1731941048380,
      "end": 1731941048381,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1731941048381,
      "end": 1731941048381,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1731941048381,
      "end": 1731941048382,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941048382,
      "end": 1731941048382,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1731941048382,
      "end": 1731941048385,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { createVNode as _createVNode } from \"vue\";\nimport \"./VSlideGroup.css\";\nimport { VFadeTransition } from \"../transitions/index.mjs\";\nimport { VIcon } from \"../VIcon/index.mjs\";\nimport { makeComponentProps } from \"../../composables/component.mjs\";\nimport { makeDisplayProps, useDisplay } from \"../../composables/display.mjs\";\nimport { makeGroupProps, useGroup } from \"../../composables/group.mjs\";\nimport { IconValue } from \"../../composables/icons.mjs\";\nimport { useRtl } from \"../../composables/locale.mjs\";\nimport { useResizeObserver } from \"../../composables/resizeObserver.mjs\";\nimport { makeTagProps } from \"../../composables/tag.mjs\";\nimport { computed, shallowRef, watch } from \"vue\";\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from \"./helpers.mjs\";\nimport { clamp, focusableChildren, genericComponent, IN_BROWSER, propsFactory, useRender } from \"../../util/index.mjs\";\nexport const VSlideGroupSymbol = Symbol.for(\"vuetify:v-slide-group\");\nexport const makeVSlideGroupProps = propsFactory({\n  centerActive: Boolean,\n  direction: {\n    type: String,\n    default: \"horizontal\"\n  },\n  symbol: {\n    type: null,\n    default: VSlideGroupSymbol\n  },\n  nextIcon: {\n    type: IconValue,\n    default: \"$next\"\n  },\n  prevIcon: {\n    type: IconValue,\n    default: \"$prev\"\n  },\n  showArrows: {\n    type: [Boolean, String],\n    validator: (v) => typeof v === \"boolean\" || [\"always\", \"desktop\", \"mobile\"].includes(v)\n  },\n  ...makeComponentProps(),\n  ...makeDisplayProps(),\n  ...makeTagProps(),\n  ...makeGroupProps({\n    selectedClass: \"v-slide-group-item--active\"\n  })\n}, \"VSlideGroup\");\nexport const VSlideGroup = genericComponent()({\n  name: \"VSlideGroup\",\n  props: makeVSlideGroupProps(),\n  emits: {\n    \"update:modelValue\": (value) => true\n  },\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const {\n      isRtl\n    } = useRtl();\n    const {\n      displayClasses,\n      mobile\n    } = useDisplay(props);\n    const group = useGroup(props, props.symbol);\n    const isOverflowing = shallowRef(false);\n    const scrollOffset = shallowRef(0);\n    const containerSize = shallowRef(0);\n    const contentSize = shallowRef(0);\n    const isHorizontal = computed(() => props.direction === \"horizontal\");\n    const {\n      resizeRef: containerRef,\n      contentRect: containerRect\n    } = useResizeObserver();\n    const {\n      resizeRef: contentRef,\n      contentRect\n    } = useResizeObserver();\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length)\n        return -1;\n      return group.items.value.findIndex((item) => item.id === group.selected.value[0]);\n    });\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length)\n        return -1;\n      return group.items.value.findIndex((item) => item.id === group.selected.value[group.selected.value.length - 1]);\n    });\n    if (IN_BROWSER) {\n      let frame = -1;\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame);\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? \"width\" : \"height\";\n            containerSize.value = containerRect.value[sizeProperty];\n            contentSize.value = contentRect.value[sizeProperty];\n            isOverflowing.value = containerSize.value + 1 < contentSize.value;\n          }\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value];\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0;\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value\n              });\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value\n              });\n            }\n          }\n        });\n      });\n    }\n    const disableTransition = shallowRef(false);\n    let startTouch = 0;\n    let startOffset = 0;\n    function onTouchstart(e) {\n      const sizeProperty = isHorizontal.value ? \"clientX\" : \"clientY\";\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      startOffset = sign * scrollOffset.value;\n      startTouch = e.touches[0][sizeProperty];\n      disableTransition.value = true;\n    }\n    function onTouchmove(e) {\n      if (!isOverflowing.value)\n        return;\n      const sizeProperty = isHorizontal.value ? \"clientX\" : \"clientY\";\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);\n    }\n    function onTouchend(e) {\n      const maxScrollOffset = contentSize.value - containerSize.value;\n      if (scrollOffset.value < 0 || !isOverflowing.value) {\n        scrollOffset.value = 0;\n      } else if (scrollOffset.value >= maxScrollOffset) {\n        scrollOffset.value = maxScrollOffset;\n      }\n      disableTransition.value = false;\n    }\n    function onScroll() {\n      if (!containerRef.value)\n        return;\n      containerRef.value[isHorizontal.value ? \"scrollLeft\" : \"scrollTop\"] = 0;\n    }\n    const isFocused = shallowRef(false);\n    function onFocusin(e) {\n      isFocused.value = true;\n      if (!isOverflowing.value || !contentRef.value)\n        return;\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value\n            });\n            return;\n          }\n        }\n      }\n    }\n    function onFocusout(e) {\n      isFocused.value = false;\n    }\n    function onFocus(e) {\n      if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget)))\n        focus();\n    }\n    function onKeydown(e) {\n      if (!contentRef.value)\n        return;\n      if (isHorizontal.value) {\n        if (e.key === \"ArrowRight\") {\n          focus(isRtl.value ? \"prev\" : \"next\");\n        } else if (e.key === \"ArrowLeft\") {\n          focus(isRtl.value ? \"next\" : \"prev\");\n        }\n      } else {\n        if (e.key === \"ArrowDown\") {\n          focus(\"next\");\n        } else if (e.key === \"ArrowUp\") {\n          focus(\"prev\");\n        }\n      }\n      if (e.key === \"Home\") {\n        focus(\"first\");\n      } else if (e.key === \"End\") {\n        focus(\"last\");\n      }\n    }\n    function focus(location) {\n      if (!contentRef.value)\n        return;\n      if (!location) {\n        const focusable = focusableChildren(contentRef.value);\n        focusable[0]?.focus();\n      } else if (location === \"next\") {\n        const el = contentRef.value.querySelector(\":focus\")?.nextElementSibling;\n        if (el)\n          el.focus();\n        else\n          focus(\"first\");\n      } else if (location === \"prev\") {\n        const el = contentRef.value.querySelector(\":focus\")?.previousElementSibling;\n        if (el)\n          el.focus();\n        else\n          focus(\"last\");\n      } else if (location === \"first\") {\n        contentRef.value.firstElementChild?.focus();\n      } else if (location === \"last\") {\n        contentRef.value.lastElementChild?.focus();\n      }\n    }\n    function scrollTo(location) {\n      const newAbsoluteOffset = scrollOffset.value + (location === \"prev\" ? -1 : 1) * containerSize.value;\n      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);\n    }\n    const contentStyles = computed(() => {\n      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;\n      if (scrollOffset.value <= 0) {\n        scrollAmount = bias(-scrollOffset.value);\n      }\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      return {\n        transform: `translate${isHorizontal.value ? \"X\" : \"Y\"}(${sign * scrollAmount}px)`,\n        transition: disableTransition.value ? \"none\" : \"\",\n        willChange: disableTransition.value ? \"transform\" : \"\"\n      };\n    });\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected\n    }));\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        case \"always\":\n          return true;\n        case \"desktop\":\n          return !mobile.value;\n        case true:\n          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n        case \"mobile\":\n          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n        default:\n          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);\n      }\n    });\n    const hasPrev = computed(() => {\n      return Math.abs(scrollOffset.value) > 0;\n    });\n    const hasNext = computed(() => {\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;\n    });\n    useRender(() => _createVNode(props.tag, {\n      \"class\": [\"v-slide-group\", {\n        \"v-slide-group--vertical\": !isHorizontal.value,\n        \"v-slide-group--has-affixes\": hasAffixes.value,\n        \"v-slide-group--is-overflowing\": isOverflowing.value\n      }, displayClasses.value, props.class],\n      \"style\": props.style,\n      \"tabindex\": isFocused.value || group.selected.value.length ? -1 : 0,\n      \"onFocus\": onFocus\n    }, {\n      default: () => [hasAffixes.value && _createVNode(\"div\", {\n        \"key\": \"prev\",\n        \"class\": [\"v-slide-group__prev\", {\n          \"v-slide-group__prev--disabled\": !hasPrev.value\n        }],\n        \"onClick\": () => hasPrev.value && scrollTo(\"prev\")\n      }, [slots.prev?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\n        default: () => [_createVNode(VIcon, {\n          \"icon\": isRtl.value ? props.nextIcon : props.prevIcon\n        }, null)]\n      })]), _createVNode(\"div\", {\n        \"key\": \"container\",\n        \"ref\": containerRef,\n        \"class\": \"v-slide-group__container\",\n        \"onScroll\": onScroll\n      }, [_createVNode(\"div\", {\n        \"ref\": contentRef,\n        \"class\": \"v-slide-group__content\",\n        \"style\": contentStyles.value,\n        \"onTouchstartPassive\": onTouchstart,\n        \"onTouchmovePassive\": onTouchmove,\n        \"onTouchendPassive\": onTouchend,\n        \"onFocusin\": onFocusin,\n        \"onFocusout\": onFocusout,\n        \"onKeydown\": onKeydown\n      }, [slots.default?.(slotProps.value)])]), hasAffixes.value && _createVNode(\"div\", {\n        \"key\": \"next\",\n        \"class\": [\"v-slide-group__next\", {\n          \"v-slide-group__next--disabled\": !hasNext.value\n        }],\n        \"onClick\": () => hasNext.value && scrollTo(\"next\")\n      }, [slots.next?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\n        default: () => [_createVNode(VIcon, {\n          \"icon\": isRtl.value ? props.prevIcon : props.nextIcon\n        }, null)]\n      })])]\n    }));\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus\n    };\n  }\n});\n",
      "start": 1731941048385,
      "end": 1731941048423,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"D:/Projects/Nabtaty-dashboard-de3bd56d6663c71275c3f076b188500fce6955c7/node_modules/vuetify/lib/components/VSlideGroup/VSlideGroup.mjs\"],\n  \"sourcesContent\": [\"import { createVNode as _createVNode } from \\\"vue\\\";\\n// Styles\\nimport \\\"./VSlideGroup.css\\\";\\n\\n// Components\\nimport { VFadeTransition } from \\\"../transitions/index.mjs\\\";\\nimport { VIcon } from \\\"../VIcon/index.mjs\\\"; // Composables\\nimport { makeComponentProps } from \\\"../../composables/component.mjs\\\";\\nimport { makeDisplayProps, useDisplay } from \\\"../../composables/display.mjs\\\";\\nimport { makeGroupProps, useGroup } from \\\"../../composables/group.mjs\\\";\\nimport { IconValue } from \\\"../../composables/icons.mjs\\\";\\nimport { useRtl } from \\\"../../composables/locale.mjs\\\";\\nimport { useResizeObserver } from \\\"../../composables/resizeObserver.mjs\\\";\\nimport { makeTagProps } from \\\"../../composables/tag.mjs\\\"; // Utilities\\nimport { computed, shallowRef, watch } from 'vue';\\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from \\\"./helpers.mjs\\\";\\nimport { clamp, focusableChildren, genericComponent, IN_BROWSER, propsFactory, useRender } from \\\"../../util/index.mjs\\\"; // Types\\nexport const VSlideGroupSymbol = Symbol.for('vuetify:v-slide-group');\\nexport const makeVSlideGroupProps = propsFactory({\\n  centerActive: Boolean,\\n  direction: {\\n    type: String,\\n    default: 'horizontal'\\n  },\\n  symbol: {\\n    type: null,\\n    default: VSlideGroupSymbol\\n  },\\n  nextIcon: {\\n    type: IconValue,\\n    default: '$next'\\n  },\\n  prevIcon: {\\n    type: IconValue,\\n    default: '$prev'\\n  },\\n  showArrows: {\\n    type: [Boolean, String],\\n    validator: v => typeof v === 'boolean' || ['always', 'desktop', 'mobile'].includes(v)\\n  },\\n  ...makeComponentProps(),\\n  ...makeDisplayProps(),\\n  ...makeTagProps(),\\n  ...makeGroupProps({\\n    selectedClass: 'v-slide-group-item--active'\\n  })\\n}, 'VSlideGroup');\\nexport const VSlideGroup = genericComponent()({\\n  name: 'VSlideGroup',\\n  props: makeVSlideGroupProps(),\\n  emits: {\\n    'update:modelValue': value => true\\n  },\\n  setup(props, _ref) {\\n    let {\\n      slots\\n    } = _ref;\\n    const {\\n      isRtl\\n    } = useRtl();\\n    const {\\n      displayClasses,\\n      mobile\\n    } = useDisplay(props);\\n    const group = useGroup(props, props.symbol);\\n    const isOverflowing = shallowRef(false);\\n    const scrollOffset = shallowRef(0);\\n    const containerSize = shallowRef(0);\\n    const contentSize = shallowRef(0);\\n    const isHorizontal = computed(() => props.direction === 'horizontal');\\n    const {\\n      resizeRef: containerRef,\\n      contentRect: containerRect\\n    } = useResizeObserver();\\n    const {\\n      resizeRef: contentRef,\\n      contentRect\\n    } = useResizeObserver();\\n    const firstSelectedIndex = computed(() => {\\n      if (!group.selected.value.length) return -1;\\n      return group.items.value.findIndex(item => item.id === group.selected.value[0]);\\n    });\\n    const lastSelectedIndex = computed(() => {\\n      if (!group.selected.value.length) return -1;\\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1]);\\n    });\\n    if (IN_BROWSER) {\\n      let frame = -1;\\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\\n        cancelAnimationFrame(frame);\\n        frame = requestAnimationFrame(() => {\\n          if (containerRect.value && contentRect.value) {\\n            const sizeProperty = isHorizontal.value ? 'width' : 'height';\\n            containerSize.value = containerRect.value[sizeProperty];\\n            contentSize.value = contentRect.value[sizeProperty];\\n            isOverflowing.value = containerSize.value + 1 < contentSize.value;\\n          }\\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\\n            // TODO: Is this too naive? Should we store element references in group composable?\\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value];\\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\\n              scrollOffset.value = 0;\\n            } else if (props.centerActive) {\\n              scrollOffset.value = calculateCenteredOffset({\\n                selectedElement,\\n                containerSize: containerSize.value,\\n                contentSize: contentSize.value,\\n                isRtl: isRtl.value,\\n                isHorizontal: isHorizontal.value\\n              });\\n            } else if (isOverflowing.value) {\\n              scrollOffset.value = calculateUpdatedOffset({\\n                selectedElement,\\n                containerSize: containerSize.value,\\n                contentSize: contentSize.value,\\n                isRtl: isRtl.value,\\n                currentScrollOffset: scrollOffset.value,\\n                isHorizontal: isHorizontal.value\\n              });\\n            }\\n          }\\n        });\\n      });\\n    }\\n    const disableTransition = shallowRef(false);\\n    let startTouch = 0;\\n    let startOffset = 0;\\n    function onTouchstart(e) {\\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\\n      startOffset = sign * scrollOffset.value;\\n      startTouch = e.touches[0][sizeProperty];\\n      disableTransition.value = true;\\n    }\\n    function onTouchmove(e) {\\n      if (!isOverflowing.value) return;\\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\\n      scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);\\n    }\\n    function onTouchend(e) {\\n      const maxScrollOffset = contentSize.value - containerSize.value;\\n      if (scrollOffset.value < 0 || !isOverflowing.value) {\\n        scrollOffset.value = 0;\\n      } else if (scrollOffset.value >= maxScrollOffset) {\\n        scrollOffset.value = maxScrollOffset;\\n      }\\n      disableTransition.value = false;\\n    }\\n    function onScroll() {\\n      if (!containerRef.value) return;\\n      containerRef.value[isHorizontal.value ? 'scrollLeft' : 'scrollTop'] = 0;\\n    }\\n    const isFocused = shallowRef(false);\\n    function onFocusin(e) {\\n      isFocused.value = true;\\n      if (!isOverflowing.value || !contentRef.value) return;\\n\\n      // Focused element is likely to be the root of an item, so a\\n      // breadth-first search will probably find it in the first iteration\\n      for (const el of e.composedPath()) {\\n        for (const item of contentRef.value.children) {\\n          if (item === el) {\\n            scrollOffset.value = calculateUpdatedOffset({\\n              selectedElement: item,\\n              containerSize: containerSize.value,\\n              contentSize: contentSize.value,\\n              isRtl: isRtl.value,\\n              currentScrollOffset: scrollOffset.value,\\n              isHorizontal: isHorizontal.value\\n            });\\n            return;\\n          }\\n        }\\n      }\\n    }\\n    function onFocusout(e) {\\n      isFocused.value = false;\\n    }\\n    function onFocus(e) {\\n      if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget))) focus();\\n    }\\n    function onKeydown(e) {\\n      if (!contentRef.value) return;\\n      if (isHorizontal.value) {\\n        if (e.key === 'ArrowRight') {\\n          focus(isRtl.value ? 'prev' : 'next');\\n        } else if (e.key === 'ArrowLeft') {\\n          focus(isRtl.value ? 'next' : 'prev');\\n        }\\n      } else {\\n        if (e.key === 'ArrowDown') {\\n          focus('next');\\n        } else if (e.key === 'ArrowUp') {\\n          focus('prev');\\n        }\\n      }\\n      if (e.key === 'Home') {\\n        focus('first');\\n      } else if (e.key === 'End') {\\n        focus('last');\\n      }\\n    }\\n    function focus(location) {\\n      if (!contentRef.value) return;\\n      if (!location) {\\n        const focusable = focusableChildren(contentRef.value);\\n        focusable[0]?.focus();\\n      } else if (location === 'next') {\\n        const el = contentRef.value.querySelector(':focus')?.nextElementSibling;\\n        if (el) el.focus();else focus('first');\\n      } else if (location === 'prev') {\\n        const el = contentRef.value.querySelector(':focus')?.previousElementSibling;\\n        if (el) el.focus();else focus('last');\\n      } else if (location === 'first') {\\n        contentRef.value.firstElementChild?.focus();\\n      } else if (location === 'last') {\\n        contentRef.value.lastElementChild?.focus();\\n      }\\n    }\\n    function scrollTo(location) {\\n      const newAbsoluteOffset = scrollOffset.value + (location === 'prev' ? -1 : 1) * containerSize.value;\\n      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);\\n    }\\n    const contentStyles = computed(() => {\\n      // This adds friction when scrolling the 'wrong' way when at max offset\\n      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;\\n\\n      // This adds friction when scrolling the 'wrong' way when at min offset\\n      if (scrollOffset.value <= 0) {\\n        scrollAmount = bias(-scrollOffset.value);\\n      }\\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\\n      return {\\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${sign * scrollAmount}px)`,\\n        transition: disableTransition.value ? 'none' : '',\\n        willChange: disableTransition.value ? 'transform' : ''\\n      };\\n    });\\n    const slotProps = computed(() => ({\\n      next: group.next,\\n      prev: group.prev,\\n      select: group.select,\\n      isSelected: group.isSelected\\n    }));\\n    const hasAffixes = computed(() => {\\n      switch (props.showArrows) {\\n        // Always show arrows on desktop & mobile\\n        case 'always':\\n          return true;\\n\\n        // Always show arrows on desktop\\n        case 'desktop':\\n          return !mobile.value;\\n\\n        // Show arrows on mobile when overflowing.\\n        // This matches the default 2.2 behavior\\n        case true:\\n          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;\\n\\n        // Always show on mobile\\n        case 'mobile':\\n          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;\\n\\n        // https://material.io/components/tabs#scrollable-tabs\\n        // Always show arrows when\\n        // overflowed on desktop\\n        default:\\n          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);\\n      }\\n    });\\n    const hasPrev = computed(() => {\\n      return Math.abs(scrollOffset.value) > 0;\\n    });\\n    const hasNext = computed(() => {\\n      // Check one scroll ahead to know the width of right-most item\\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;\\n    });\\n    useRender(() => _createVNode(props.tag, {\\n      \\\"class\\\": ['v-slide-group', {\\n        'v-slide-group--vertical': !isHorizontal.value,\\n        'v-slide-group--has-affixes': hasAffixes.value,\\n        'v-slide-group--is-overflowing': isOverflowing.value\\n      }, displayClasses.value, props.class],\\n      \\\"style\\\": props.style,\\n      \\\"tabindex\\\": isFocused.value || group.selected.value.length ? -1 : 0,\\n      \\\"onFocus\\\": onFocus\\n    }, {\\n      default: () => [hasAffixes.value && _createVNode(\\\"div\\\", {\\n        \\\"key\\\": \\\"prev\\\",\\n        \\\"class\\\": ['v-slide-group__prev', {\\n          'v-slide-group__prev--disabled': !hasPrev.value\\n        }],\\n        \\\"onClick\\\": () => hasPrev.value && scrollTo('prev')\\n      }, [slots.prev?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\\n        default: () => [_createVNode(VIcon, {\\n          \\\"icon\\\": isRtl.value ? props.nextIcon : props.prevIcon\\n        }, null)]\\n      })]), _createVNode(\\\"div\\\", {\\n        \\\"key\\\": \\\"container\\\",\\n        \\\"ref\\\": containerRef,\\n        \\\"class\\\": \\\"v-slide-group__container\\\",\\n        \\\"onScroll\\\": onScroll\\n      }, [_createVNode(\\\"div\\\", {\\n        \\\"ref\\\": contentRef,\\n        \\\"class\\\": \\\"v-slide-group__content\\\",\\n        \\\"style\\\": contentStyles.value,\\n        \\\"onTouchstartPassive\\\": onTouchstart,\\n        \\\"onTouchmovePassive\\\": onTouchmove,\\n        \\\"onTouchendPassive\\\": onTouchend,\\n        \\\"onFocusin\\\": onFocusin,\\n        \\\"onFocusout\\\": onFocusout,\\n        \\\"onKeydown\\\": onKeydown\\n      }, [slots.default?.(slotProps.value)])]), hasAffixes.value && _createVNode(\\\"div\\\", {\\n        \\\"key\\\": \\\"next\\\",\\n        \\\"class\\\": ['v-slide-group__next', {\\n          'v-slide-group__next--disabled': !hasNext.value\\n        }],\\n        \\\"onClick\\\": () => hasNext.value && scrollTo('next')\\n      }, [slots.next?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\\n        default: () => [_createVNode(VIcon, {\\n          \\\"icon\\\": isRtl.value ? props.prevIcon : props.nextIcon\\n        }, null)]\\n      })])]\\n    }));\\n    return {\\n      selected: group.selected,\\n      scrollTo,\\n      scrollOffset,\\n      focus\\n    };\\n  }\\n});\\n//# sourceMappingURL=VSlideGroup.mjs.map\"],\n  \"mappings\": \"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\",\n  \"names\": []\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1731941048423,
      "end": 1731941048423,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1731941048423,
      "end": 1731941048423,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1731941048423,
      "end": 1731941048423,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1731941048424,
      "end": 1731941048424,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1731941048425,
      "end": 1731941048425,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1731941048426,
      "end": 1731941048426,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1731941048426,
      "end": 1731941048426,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1731941048428,
      "end": 1731941048428,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1731941048429,
      "end": 1731941048429,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1731941048429,
      "end": 1731941048429,
      "order": "normal"
    }
  ]
}
