{
  "resolvedId": "D:/Projects/Nabtaty-dashboard-de3bd56d6663c71275c3f076b188500fce6955c7/node_modules/vuetify/lib/components/VOverlay/locationStrategies.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "// Composables\nimport { useToggleScope } from \"../../composables/toggleScope.mjs\"; // Utilities\nimport { computed, nextTick, onScopeDispose, ref, watch } from 'vue';\nimport { anchorToPoint, getOffset } from \"./util/point.mjs\";\nimport { clamp, consoleError, convertToUnit, destructComputed, flipAlign, flipCorner, flipSide, getAxis, getScrollParents, IN_BROWSER, isFixedPosition, nullifyTransforms, parseAnchor, propsFactory } from \"../../util/index.mjs\";\nimport { Box, getOverflow, getTargetBox } from \"../../util/box.mjs\"; // Types\nconst locationStrategies = {\n  static: staticLocationStrategy,\n  // specific viewport position, usually centered\n  connected: connectedLocationStrategy // connected to a certain element\n};\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function],\n    default: 'static',\n    validator: val => typeof val === 'function' || val in locationStrategies\n  },\n  location: {\n    type: String,\n    default: 'bottom'\n  },\n  origin: {\n    type: String,\n    default: 'auto'\n  },\n  offset: [Number, String, Array]\n}, 'VOverlay-location-strategies');\nexport function useLocationStrategies(props, data) {\n  const contentStyles = ref({});\n  const updateLocation = ref();\n  if (IN_BROWSER) {\n    useToggleScope(() => !!(data.isActive.value && props.locationStrategy), reset => {\n      watch(() => props.locationStrategy, reset);\n      onScopeDispose(() => {\n        window.removeEventListener('resize', onResize);\n        updateLocation.value = undefined;\n      });\n      window.addEventListener('resize', onResize, {\n        passive: true\n      });\n      if (typeof props.locationStrategy === 'function') {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation;\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation;\n      }\n    });\n  }\n  function onResize(e) {\n    updateLocation.value?.(e);\n  }\n  return {\n    contentStyles,\n    updateLocation\n  };\n}\nfunction staticLocationStrategy() {\n  // TODO\n}\n\n/** Get size of element ignoring max-width/max-height */\nfunction getIntrinsicSize(el, isRtl) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  if (isRtl) {\n    el.style.removeProperty('left');\n  } else {\n    el.style.removeProperty('right');\n  }\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el);\n  if (isRtl) {\n    contentBox.x += parseFloat(el.style.right || 0);\n  } else {\n    contentBox.x -= parseFloat(el.style.left || 0);\n  }\n  contentBox.y -= parseFloat(el.style.top || 0);\n\n  // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox;\n}\nfunction connectedLocationStrategy(data, props, contentStyles) {\n  const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed',\n      top: 0,\n      [data.isRtl.value ? 'right' : 'left']: 0\n    });\n  }\n  const {\n    preferredAnchor,\n    preferredOrigin\n  } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value);\n    const parsedOrigin = props.origin === 'overlap' ? parsedAnchor : props.origin === 'auto' ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);\n\n    // Some combinations of props may produce an invalid origin\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin)\n      };\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin\n      };\n    }\n  });\n  const [minWidth, minHeight, maxWidth, maxHeight] = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map(key => {\n    return computed(() => {\n      const val = parseFloat(props[key]);\n      return isNaN(val) ? Infinity : val;\n    });\n  });\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset;\n    }\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat);\n      if (offset.length < 2) offset.push(0);\n      return offset;\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0];\n  });\n  let observe = false;\n  const observer = new ResizeObserver(() => {\n    if (observe) updateLocation();\n  });\n  watch([data.target, data.contentEl], (_ref, _ref2) => {\n    let [newTarget, newContentEl] = _ref;\n    let [oldTarget, oldContentEl] = _ref2;\n    if (oldTarget && !Array.isArray(oldTarget)) observer.unobserve(oldTarget);\n    if (newTarget && !Array.isArray(newTarget)) observer.observe(newTarget);\n    if (oldContentEl) observer.unobserve(oldContentEl);\n    if (newContentEl) observer.observe(newContentEl);\n  }, {\n    immediate: true\n  });\n  onScopeDispose(() => {\n    observer.disconnect();\n  });\n\n  // eslint-disable-next-line max-statements\n  function updateLocation() {\n    observe = false;\n    requestAnimationFrame(() => observe = true);\n    if (!data.target.value || !data.contentEl.value) return;\n    const targetBox = getTargetBox(data.target.value);\n    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);\n    const scrollParents = getScrollParents(data.contentEl.value);\n    const viewportMargin = 12;\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement);\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0);\n        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0);\n      }\n    }\n    const viewport = scrollParents.reduce((box, el) => {\n      const rect = el.getBoundingClientRect();\n      const scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight\n      });\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)\n        });\n      }\n      return scrollBox;\n    }, undefined);\n    viewport.x += viewportMargin;\n    viewport.y += viewportMargin;\n    viewport.width -= viewportMargin * 2;\n    viewport.height -= viewportMargin * 2;\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value\n    };\n    function checkOverflow(_placement) {\n      const box = new Box(contentBox);\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox);\n      const contentPoint = anchorToPoint(_placement.origin, box);\n      let {\n        x,\n        y\n      } = getOffset(targetPoint, contentPoint);\n      switch (_placement.anchor.side) {\n        case 'top':\n          y -= offset.value[0];\n          break;\n        case 'bottom':\n          y += offset.value[0];\n          break;\n        case 'left':\n          x -= offset.value[0];\n          break;\n        case 'right':\n          x += offset.value[0];\n          break;\n      }\n      switch (_placement.anchor.align) {\n        case 'top':\n          y -= offset.value[1];\n          break;\n        case 'bottom':\n          y += offset.value[1];\n          break;\n        case 'left':\n          x -= offset.value[1];\n          break;\n        case 'right':\n          x += offset.value[1];\n          break;\n      }\n      box.x += x;\n      box.y += y;\n      box.width = Math.min(box.width, maxWidth.value);\n      box.height = Math.min(box.height, maxHeight.value);\n      const overflows = getOverflow(box, viewport);\n      return {\n        overflows,\n        x,\n        y\n      };\n    }\n    let x = 0;\n    let y = 0;\n    const available = {\n      x: 0,\n      y: 0\n    };\n    const flipped = {\n      x: false,\n      y: false\n    };\n    let resets = -1;\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy');\n        break;\n      }\n      const {\n        x: _x,\n        y: _y,\n        overflows\n      } = checkOverflow(placement);\n      x += _x;\n      y += _y;\n      contentBox.x += _x;\n      contentBox.y += _y;\n\n      // flip\n      {\n        const axis = getAxis(placement.anchor);\n        const hasOverflowX = overflows.x.before || overflows.x.after;\n        const hasOverflowY = overflows.y.before || overflows.y.after;\n        let reset = false;\n        ['x', 'y'].forEach(key => {\n          if (key === 'x' && hasOverflowX && !flipped.x || key === 'y' && hasOverflowY && !flipped.y) {\n            const newPlacement = {\n              anchor: {\n                ...placement.anchor\n              },\n              origin: {\n                ...placement.origin\n              }\n            };\n            const flip = key === 'x' ? axis === 'y' ? flipAlign : flipSide : axis === 'y' ? flipSide : flipAlign;\n            newPlacement.anchor = flip(newPlacement.anchor);\n            newPlacement.origin = flip(newPlacement.origin);\n            const {\n              overflows: newOverflows\n            } = checkOverflow(newPlacement);\n            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {\n              placement = newPlacement;\n              reset = flipped[key] = true;\n            }\n          }\n        });\n        if (reset) continue;\n      }\n\n      // shift\n      if (overflows.x.before) {\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after;\n        contentBox.x -= overflows.x.after;\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after;\n        contentBox.y -= overflows.y.after;\n      }\n\n      // size\n      {\n        const overflows = getOverflow(contentBox, viewport);\n        available.x = viewport.width - overflows.x.before - overflows.x.after;\n        available.y = viewport.height - overflows.y.before - overflows.y.after;\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n      break;\n    }\n    const axis = getAxis(placement.anchor);\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: data.isRtl.value ? undefined : convertToUnit(pixelRound(x)),\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : undefined,\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))\n    });\n    return {\n      available,\n      contentBox\n    };\n  }\n  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());\n  nextTick(() => {\n    const result = updateLocation();\n\n    // TODO: overflowing content should only require a single updateLocation call\n    // Icky hack to make sure the content is positioned consistently\n    if (!result) return;\n    const {\n      available,\n      contentBox\n    } = result;\n    if (contentBox.height > available.y) {\n      requestAnimationFrame(() => {\n        updateLocation();\n        requestAnimationFrame(() => {\n          updateLocation();\n        });\n      });\n    }\n  });\n  return {\n    updateLocation\n  };\n}\nfunction pixelRound(val) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio;\n}\nfunction pixelCeil(val) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;\n}\n//# sourceMappingURL=locationStrategies.mjs.map",
      "start": 1731941051059,
      "end": 1731941051282,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1731941051282,
      "end": 1731941051282,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1731941051282,
      "end": 1731941051282,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1731941051282,
      "end": 1731941051282,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1731941051282,
      "end": 1731941051282,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1731941051282,
      "end": 1731941051282,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1731941051282,
      "end": 1731941051282,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1731941051282,
      "end": 1731941051283,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1731941051283,
      "end": 1731941051283,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1731941051283,
      "end": 1731941051285,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { useToggleScope } from \"../../composables/toggleScope.mjs\";\nimport { computed, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { anchorToPoint, getOffset } from \"./util/point.mjs\";\nimport { clamp, consoleError, convertToUnit, destructComputed, flipAlign, flipCorner, flipSide, getAxis, getScrollParents, IN_BROWSER, isFixedPosition, nullifyTransforms, parseAnchor, propsFactory } from \"../../util/index.mjs\";\nimport { Box, getOverflow, getTargetBox } from \"../../util/box.mjs\";\nconst locationStrategies = {\n  static: staticLocationStrategy,\n  // specific viewport position, usually centered\n  connected: connectedLocationStrategy\n  // connected to a certain element\n};\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function],\n    default: \"static\",\n    validator: (val) => typeof val === \"function\" || val in locationStrategies\n  },\n  location: {\n    type: String,\n    default: \"bottom\"\n  },\n  origin: {\n    type: String,\n    default: \"auto\"\n  },\n  offset: [Number, String, Array]\n}, \"VOverlay-location-strategies\");\nexport function useLocationStrategies(props, data) {\n  const contentStyles = ref({});\n  const updateLocation = ref();\n  if (IN_BROWSER) {\n    useToggleScope(() => !!(data.isActive.value && props.locationStrategy), (reset) => {\n      watch(() => props.locationStrategy, reset);\n      onScopeDispose(() => {\n        (void 0).removeEventListener(\"resize\", onResize);\n        updateLocation.value = void 0;\n      });\n      (void 0).addEventListener(\"resize\", onResize, {\n        passive: true\n      });\n      if (typeof props.locationStrategy === \"function\") {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation;\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation;\n      }\n    });\n  }\n  function onResize(e) {\n    updateLocation.value?.(e);\n  }\n  return {\n    contentStyles,\n    updateLocation\n  };\n}\nfunction staticLocationStrategy() {\n}\nfunction getIntrinsicSize(el, isRtl) {\n  if (isRtl) {\n    el.style.removeProperty(\"left\");\n  } else {\n    el.style.removeProperty(\"right\");\n  }\n  const contentBox = nullifyTransforms(el);\n  if (isRtl) {\n    contentBox.x += parseFloat(el.style.right || 0);\n  } else {\n    contentBox.x -= parseFloat(el.style.left || 0);\n  }\n  contentBox.y -= parseFloat(el.style.top || 0);\n  return contentBox;\n}\nfunction connectedLocationStrategy(data, props, contentStyles) {\n  const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: \"fixed\",\n      top: 0,\n      [data.isRtl.value ? \"right\" : \"left\"]: 0\n    });\n  }\n  const {\n    preferredAnchor,\n    preferredOrigin\n  } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value);\n    const parsedOrigin = props.origin === \"overlap\" ? parsedAnchor : props.origin === \"auto\" ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin)\n      };\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin\n      };\n    }\n  });\n  const [minWidth, minHeight, maxWidth, maxHeight] = [\"minWidth\", \"minHeight\", \"maxWidth\", \"maxHeight\"].map((key) => {\n    return computed(() => {\n      const val = parseFloat(props[key]);\n      return isNaN(val) ? Infinity : val;\n    });\n  });\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset;\n    }\n    if (typeof props.offset === \"string\") {\n      const offset2 = props.offset.split(\" \").map(parseFloat);\n      if (offset2.length < 2)\n        offset2.push(0);\n      return offset2;\n    }\n    return typeof props.offset === \"number\" ? [props.offset, 0] : [0, 0];\n  });\n  let observe = false;\n  const observer = new ResizeObserver(() => {\n    if (observe)\n      updateLocation();\n  });\n  watch([data.target, data.contentEl], (_ref, _ref2) => {\n    let [newTarget, newContentEl] = _ref;\n    let [oldTarget, oldContentEl] = _ref2;\n    if (oldTarget && !Array.isArray(oldTarget))\n      observer.unobserve(oldTarget);\n    if (newTarget && !Array.isArray(newTarget))\n      observer.observe(newTarget);\n    if (oldContentEl)\n      observer.unobserve(oldContentEl);\n    if (newContentEl)\n      observer.observe(newContentEl);\n  }, {\n    immediate: true\n  });\n  onScopeDispose(() => {\n    observer.disconnect();\n  });\n  function updateLocation() {\n    observe = false;\n    requestAnimationFrame(() => observe = true);\n    if (!data.target.value || !data.contentEl.value)\n      return;\n    const targetBox = getTargetBox(data.target.value);\n    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);\n    const scrollParents = getScrollParents(data.contentEl.value);\n    const viewportMargin = 12;\n    if (!scrollParents.length) {\n      scrollParents.push((void 0).documentElement);\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x -= parseFloat((void 0).documentElement.style.getPropertyValue(\"--v-body-scroll-x\") || 0);\n        contentBox.y -= parseFloat((void 0).documentElement.style.getPropertyValue(\"--v-body-scroll-y\") || 0);\n      }\n    }\n    const viewport = scrollParents.reduce((box, el) => {\n      const rect = el.getBoundingClientRect();\n      const scrollBox = new Box({\n        x: el === (void 0).documentElement ? 0 : rect.x,\n        y: el === (void 0).documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight\n      });\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)\n        });\n      }\n      return scrollBox;\n    }, void 0);\n    viewport.x += viewportMargin;\n    viewport.y += viewportMargin;\n    viewport.width -= viewportMargin * 2;\n    viewport.height -= viewportMargin * 2;\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value\n    };\n    function checkOverflow(_placement) {\n      const box = new Box(contentBox);\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox);\n      const contentPoint = anchorToPoint(_placement.origin, box);\n      let {\n        x: x2,\n        y: y2\n      } = getOffset(targetPoint, contentPoint);\n      switch (_placement.anchor.side) {\n        case \"top\":\n          y2 -= offset.value[0];\n          break;\n        case \"bottom\":\n          y2 += offset.value[0];\n          break;\n        case \"left\":\n          x2 -= offset.value[0];\n          break;\n        case \"right\":\n          x2 += offset.value[0];\n          break;\n      }\n      switch (_placement.anchor.align) {\n        case \"top\":\n          y2 -= offset.value[1];\n          break;\n        case \"bottom\":\n          y2 += offset.value[1];\n          break;\n        case \"left\":\n          x2 -= offset.value[1];\n          break;\n        case \"right\":\n          x2 += offset.value[1];\n          break;\n      }\n      box.x += x2;\n      box.y += y2;\n      box.width = Math.min(box.width, maxWidth.value);\n      box.height = Math.min(box.height, maxHeight.value);\n      const overflows = getOverflow(box, viewport);\n      return {\n        overflows,\n        x: x2,\n        y: y2\n      };\n    }\n    let x = 0;\n    let y = 0;\n    const available = {\n      x: 0,\n      y: 0\n    };\n    const flipped = {\n      x: false,\n      y: false\n    };\n    let resets = -1;\n    while (true) {\n      if (resets++ > 10) {\n        consoleError(\"Infinite loop detected in connectedLocationStrategy\");\n        break;\n      }\n      const {\n        x: _x,\n        y: _y,\n        overflows\n      } = checkOverflow(placement);\n      x += _x;\n      y += _y;\n      contentBox.x += _x;\n      contentBox.y += _y;\n      {\n        const axis2 = getAxis(placement.anchor);\n        const hasOverflowX = overflows.x.before || overflows.x.after;\n        const hasOverflowY = overflows.y.before || overflows.y.after;\n        let reset = false;\n        [\"x\", \"y\"].forEach((key) => {\n          if (key === \"x\" && hasOverflowX && !flipped.x || key === \"y\" && hasOverflowY && !flipped.y) {\n            const newPlacement = {\n              anchor: {\n                ...placement.anchor\n              },\n              origin: {\n                ...placement.origin\n              }\n            };\n            const flip = key === \"x\" ? axis2 === \"y\" ? flipAlign : flipSide : axis2 === \"y\" ? flipSide : flipAlign;\n            newPlacement.anchor = flip(newPlacement.anchor);\n            newPlacement.origin = flip(newPlacement.origin);\n            const {\n              overflows: newOverflows\n            } = checkOverflow(newPlacement);\n            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {\n              placement = newPlacement;\n              reset = flipped[key] = true;\n            }\n          }\n        });\n        if (reset)\n          continue;\n      }\n      if (overflows.x.before) {\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after;\n        contentBox.x -= overflows.x.after;\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after;\n        contentBox.y -= overflows.y.after;\n      }\n      {\n        const overflows2 = getOverflow(contentBox, viewport);\n        available.x = viewport.width - overflows2.x.before - overflows2.x.after;\n        available.y = viewport.height - overflows2.y.before - overflows2.y.after;\n        x += overflows2.x.before;\n        contentBox.x += overflows2.x.before;\n        y += overflows2.y.before;\n        contentBox.y += overflows2.y.before;\n      }\n      break;\n    }\n    const axis = getAxis(placement.anchor);\n    Object.assign(contentStyles.value, {\n      \"--v-overlay-anchor-origin\": `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: data.isRtl.value ? void 0 : convertToUnit(pixelRound(x)),\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : void 0,\n      minWidth: convertToUnit(axis === \"y\" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))\n    });\n    return {\n      available,\n      contentBox\n    };\n  }\n  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());\n  nextTick(() => {\n    const result = updateLocation();\n    if (!result)\n      return;\n    const {\n      available,\n      contentBox\n    } = result;\n    if (contentBox.height > available.y) {\n      requestAnimationFrame(() => {\n        updateLocation();\n        requestAnimationFrame(() => {\n          updateLocation();\n        });\n      });\n    }\n  });\n  return {\n    updateLocation\n  };\n}\nfunction pixelRound(val) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio;\n}\nfunction pixelCeil(val) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;\n}\n",
      "start": 1731941051285,
      "end": 1731941051384,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"D:/Projects/Nabtaty-dashboard-de3bd56d6663c71275c3f076b188500fce6955c7/node_modules/vuetify/lib/components/VOverlay/locationStrategies.mjs\"],\n  \"sourcesContent\": [\"// Composables\\nimport { useToggleScope } from \\\"../../composables/toggleScope.mjs\\\"; // Utilities\\nimport { computed, nextTick, onScopeDispose, ref, watch } from 'vue';\\nimport { anchorToPoint, getOffset } from \\\"./util/point.mjs\\\";\\nimport { clamp, consoleError, convertToUnit, destructComputed, flipAlign, flipCorner, flipSide, getAxis, getScrollParents, IN_BROWSER, isFixedPosition, nullifyTransforms, parseAnchor, propsFactory } from \\\"../../util/index.mjs\\\";\\nimport { Box, getOverflow, getTargetBox } from \\\"../../util/box.mjs\\\"; // Types\\nconst locationStrategies = {\\n  static: staticLocationStrategy,\\n  // specific viewport position, usually centered\\n  connected: connectedLocationStrategy // connected to a certain element\\n};\\nexport const makeLocationStrategyProps = propsFactory({\\n  locationStrategy: {\\n    type: [String, Function],\\n    default: 'static',\\n    validator: val => typeof val === 'function' || val in locationStrategies\\n  },\\n  location: {\\n    type: String,\\n    default: 'bottom'\\n  },\\n  origin: {\\n    type: String,\\n    default: 'auto'\\n  },\\n  offset: [Number, String, Array]\\n}, 'VOverlay-location-strategies');\\nexport function useLocationStrategies(props, data) {\\n  const contentStyles = ref({});\\n  const updateLocation = ref();\\n  if (IN_BROWSER) {\\n    useToggleScope(() => !!(data.isActive.value && props.locationStrategy), reset => {\\n      watch(() => props.locationStrategy, reset);\\n      onScopeDispose(() => {\\n        window.removeEventListener('resize', onResize);\\n        updateLocation.value = undefined;\\n      });\\n      window.addEventListener('resize', onResize, {\\n        passive: true\\n      });\\n      if (typeof props.locationStrategy === 'function') {\\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation;\\n      } else {\\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation;\\n      }\\n    });\\n  }\\n  function onResize(e) {\\n    updateLocation.value?.(e);\\n  }\\n  return {\\n    contentStyles,\\n    updateLocation\\n  };\\n}\\nfunction staticLocationStrategy() {\\n  // TODO\\n}\\n\\n/** Get size of element ignoring max-width/max-height */\\nfunction getIntrinsicSize(el, isRtl) {\\n  // const scrollables = new Map<Element, [number, number]>()\\n  // el.querySelectorAll('*').forEach(el => {\\n  //   const x = el.scrollLeft\\n  //   const y = el.scrollTop\\n  //   if (x || y) {\\n  //     scrollables.set(el, [x, y])\\n  //   }\\n  // })\\n\\n  // const initialMaxWidth = el.style.maxWidth\\n  // const initialMaxHeight = el.style.maxHeight\\n  // el.style.removeProperty('max-width')\\n  // el.style.removeProperty('max-height')\\n\\n  if (isRtl) {\\n    el.style.removeProperty('left');\\n  } else {\\n    el.style.removeProperty('right');\\n  }\\n\\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\\n  const contentBox = nullifyTransforms(el);\\n  if (isRtl) {\\n    contentBox.x += parseFloat(el.style.right || 0);\\n  } else {\\n    contentBox.x -= parseFloat(el.style.left || 0);\\n  }\\n  contentBox.y -= parseFloat(el.style.top || 0);\\n\\n  // el.style.maxWidth = initialMaxWidth\\n  // el.style.maxHeight = initialMaxHeight\\n  // scrollables.forEach((position, el) => {\\n  //   el.scrollTo(...position)\\n  // })\\n\\n  return contentBox;\\n}\\nfunction connectedLocationStrategy(data, props, contentStyles) {\\n  const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);\\n  if (activatorFixed) {\\n    Object.assign(contentStyles.value, {\\n      position: 'fixed',\\n      top: 0,\\n      [data.isRtl.value ? 'right' : 'left']: 0\\n    });\\n  }\\n  const {\\n    preferredAnchor,\\n    preferredOrigin\\n  } = destructComputed(() => {\\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value);\\n    const parsedOrigin = props.origin === 'overlap' ? parsedAnchor : props.origin === 'auto' ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);\\n\\n    // Some combinations of props may produce an invalid origin\\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\\n      return {\\n        preferredAnchor: flipCorner(parsedAnchor),\\n        preferredOrigin: flipCorner(parsedOrigin)\\n      };\\n    } else {\\n      return {\\n        preferredAnchor: parsedAnchor,\\n        preferredOrigin: parsedOrigin\\n      };\\n    }\\n  });\\n  const [minWidth, minHeight, maxWidth, maxHeight] = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map(key => {\\n    return computed(() => {\\n      const val = parseFloat(props[key]);\\n      return isNaN(val) ? Infinity : val;\\n    });\\n  });\\n  const offset = computed(() => {\\n    if (Array.isArray(props.offset)) {\\n      return props.offset;\\n    }\\n    if (typeof props.offset === 'string') {\\n      const offset = props.offset.split(' ').map(parseFloat);\\n      if (offset.length < 2) offset.push(0);\\n      return offset;\\n    }\\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0];\\n  });\\n  let observe = false;\\n  const observer = new ResizeObserver(() => {\\n    if (observe) updateLocation();\\n  });\\n  watch([data.target, data.contentEl], (_ref, _ref2) => {\\n    let [newTarget, newContentEl] = _ref;\\n    let [oldTarget, oldContentEl] = _ref2;\\n    if (oldTarget && !Array.isArray(oldTarget)) observer.unobserve(oldTarget);\\n    if (newTarget && !Array.isArray(newTarget)) observer.observe(newTarget);\\n    if (oldContentEl) observer.unobserve(oldContentEl);\\n    if (newContentEl) observer.observe(newContentEl);\\n  }, {\\n    immediate: true\\n  });\\n  onScopeDispose(() => {\\n    observer.disconnect();\\n  });\\n\\n  // eslint-disable-next-line max-statements\\n  function updateLocation() {\\n    observe = false;\\n    requestAnimationFrame(() => observe = true);\\n    if (!data.target.value || !data.contentEl.value) return;\\n    const targetBox = getTargetBox(data.target.value);\\n    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);\\n    const scrollParents = getScrollParents(data.contentEl.value);\\n    const viewportMargin = 12;\\n    if (!scrollParents.length) {\\n      scrollParents.push(document.documentElement);\\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\\n        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0);\\n        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0);\\n      }\\n    }\\n    const viewport = scrollParents.reduce((box, el) => {\\n      const rect = el.getBoundingClientRect();\\n      const scrollBox = new Box({\\n        x: el === document.documentElement ? 0 : rect.x,\\n        y: el === document.documentElement ? 0 : rect.y,\\n        width: el.clientWidth,\\n        height: el.clientHeight\\n      });\\n      if (box) {\\n        return new Box({\\n          x: Math.max(box.left, scrollBox.left),\\n          y: Math.max(box.top, scrollBox.top),\\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)\\n        });\\n      }\\n      return scrollBox;\\n    }, undefined);\\n    viewport.x += viewportMargin;\\n    viewport.y += viewportMargin;\\n    viewport.width -= viewportMargin * 2;\\n    viewport.height -= viewportMargin * 2;\\n    let placement = {\\n      anchor: preferredAnchor.value,\\n      origin: preferredOrigin.value\\n    };\\n    function checkOverflow(_placement) {\\n      const box = new Box(contentBox);\\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox);\\n      const contentPoint = anchorToPoint(_placement.origin, box);\\n      let {\\n        x,\\n        y\\n      } = getOffset(targetPoint, contentPoint);\\n      switch (_placement.anchor.side) {\\n        case 'top':\\n          y -= offset.value[0];\\n          break;\\n        case 'bottom':\\n          y += offset.value[0];\\n          break;\\n        case 'left':\\n          x -= offset.value[0];\\n          break;\\n        case 'right':\\n          x += offset.value[0];\\n          break;\\n      }\\n      switch (_placement.anchor.align) {\\n        case 'top':\\n          y -= offset.value[1];\\n          break;\\n        case 'bottom':\\n          y += offset.value[1];\\n          break;\\n        case 'left':\\n          x -= offset.value[1];\\n          break;\\n        case 'right':\\n          x += offset.value[1];\\n          break;\\n      }\\n      box.x += x;\\n      box.y += y;\\n      box.width = Math.min(box.width, maxWidth.value);\\n      box.height = Math.min(box.height, maxHeight.value);\\n      const overflows = getOverflow(box, viewport);\\n      return {\\n        overflows,\\n        x,\\n        y\\n      };\\n    }\\n    let x = 0;\\n    let y = 0;\\n    const available = {\\n      x: 0,\\n      y: 0\\n    };\\n    const flipped = {\\n      x: false,\\n      y: false\\n    };\\n    let resets = -1;\\n    while (true) {\\n      if (resets++ > 10) {\\n        consoleError('Infinite loop detected in connectedLocationStrategy');\\n        break;\\n      }\\n      const {\\n        x: _x,\\n        y: _y,\\n        overflows\\n      } = checkOverflow(placement);\\n      x += _x;\\n      y += _y;\\n      contentBox.x += _x;\\n      contentBox.y += _y;\\n\\n      // flip\\n      {\\n        const axis = getAxis(placement.anchor);\\n        const hasOverflowX = overflows.x.before || overflows.x.after;\\n        const hasOverflowY = overflows.y.before || overflows.y.after;\\n        let reset = false;\\n        ['x', 'y'].forEach(key => {\\n          if (key === 'x' && hasOverflowX && !flipped.x || key === 'y' && hasOverflowY && !flipped.y) {\\n            const newPlacement = {\\n              anchor: {\\n                ...placement.anchor\\n              },\\n              origin: {\\n                ...placement.origin\\n              }\\n            };\\n            const flip = key === 'x' ? axis === 'y' ? flipAlign : flipSide : axis === 'y' ? flipSide : flipAlign;\\n            newPlacement.anchor = flip(newPlacement.anchor);\\n            newPlacement.origin = flip(newPlacement.origin);\\n            const {\\n              overflows: newOverflows\\n            } = checkOverflow(newPlacement);\\n            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {\\n              placement = newPlacement;\\n              reset = flipped[key] = true;\\n            }\\n          }\\n        });\\n        if (reset) continue;\\n      }\\n\\n      // shift\\n      if (overflows.x.before) {\\n        x += overflows.x.before;\\n        contentBox.x += overflows.x.before;\\n      }\\n      if (overflows.x.after) {\\n        x -= overflows.x.after;\\n        contentBox.x -= overflows.x.after;\\n      }\\n      if (overflows.y.before) {\\n        y += overflows.y.before;\\n        contentBox.y += overflows.y.before;\\n      }\\n      if (overflows.y.after) {\\n        y -= overflows.y.after;\\n        contentBox.y -= overflows.y.after;\\n      }\\n\\n      // size\\n      {\\n        const overflows = getOverflow(contentBox, viewport);\\n        available.x = viewport.width - overflows.x.before - overflows.x.after;\\n        available.y = viewport.height - overflows.y.before - overflows.y.after;\\n        x += overflows.x.before;\\n        contentBox.x += overflows.x.before;\\n        y += overflows.y.before;\\n        contentBox.y += overflows.y.before;\\n      }\\n      break;\\n    }\\n    const axis = getAxis(placement.anchor);\\n    Object.assign(contentStyles.value, {\\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\\n      top: convertToUnit(pixelRound(y)),\\n      left: data.isRtl.value ? undefined : convertToUnit(pixelRound(x)),\\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : undefined,\\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))\\n    });\\n    return {\\n      available,\\n      contentBox\\n    };\\n  }\\n  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());\\n  nextTick(() => {\\n    const result = updateLocation();\\n\\n    // TODO: overflowing content should only require a single updateLocation call\\n    // Icky hack to make sure the content is positioned consistently\\n    if (!result) return;\\n    const {\\n      available,\\n      contentBox\\n    } = result;\\n    if (contentBox.height > available.y) {\\n      requestAnimationFrame(() => {\\n        updateLocation();\\n        requestAnimationFrame(() => {\\n          updateLocation();\\n        });\\n      });\\n    }\\n  });\\n  return {\\n    updateLocation\\n  };\\n}\\nfunction pixelRound(val) {\\n  return Math.round(val * devicePixelRatio) / devicePixelRatio;\\n}\\nfunction pixelCeil(val) {\\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;\\n}\\n//# sourceMappingURL=locationStrategies.mjs.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"offset\", \"x\", \"y\", \"axis\", \"overflows\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1731941051384,
      "end": 1731941051384,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1731941051384,
      "end": 1731941051384,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1731941051384,
      "end": 1731941051384,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1731941051384,
      "end": 1731941051384,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1731941051384,
      "end": 1731941051384,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1731941051384,
      "end": 1731941051384,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1731941051385,
      "end": 1731941051385,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1731941051386,
      "end": 1731941051386,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1731941051386,
      "end": 1731941051386,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1731941051386,
      "end": 1731941051386,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1731941051386,
      "end": 1731941051386,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1731941051386,
      "end": 1731941051386,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1731941051386,
      "end": 1731941051386,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1731941051386,
      "end": 1731941051386,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1731941051386,
      "end": 1731941051386,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1731941051386,
      "end": 1731941051387,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1731941051387,
      "end": 1731941051387,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1731941051387,
      "end": 1731941051387,
      "order": "normal"
    }
  ]
}
