{"version":3,"file":"fetch-C1NEePYn.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../node_modules/nuxt/dist/app/composables/fetch.js"],"sourcesContent":["import { computed, getCurrentInstance, onBeforeMount, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, unref, watch } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, _handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = nuxtApp.runWithContext(_handler);\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const getDefault = () => null;\n  const getDefaultCachedData = () => nuxtApp.isHydrating ? nuxtApp.payload.data[key] : nuxtApp.static.data[key];\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  options.getCachedData = options.getCachedData ?? getDefaultCachedData;\n  options.lazy = options.lazy ?? false;\n  options.immediate = options.immediate ?? true;\n  options.deep = options.deep ?? asyncDataDefaults.deep;\n  options.dedupe = options.dedupe ?? \"cancel\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(\"[nuxt] `boolean` values are deprecated for the `dedupe` option of `useAsyncData` and will be removed in the future. Use 'cancel' or 'defer' instead.\");\n  }\n  const hasCachedData = () => options.getCachedData(key, nuxtApp) != null;\n  if (!nuxtApp._asyncData[key] || !options.immediate) {\n    nuxtApp.payload._errors[key] ??= null;\n    const _ref = options.deep ? ref : shallowRef;\n    nuxtApp._asyncData[key] = {\n      data: _ref(options.getCachedData(key, nuxtApp) ?? options.default()),\n      pending: ref(!hasCachedData()),\n      error: toRef(nuxtApp.payload._errors, key),\n      status: ref(\"idle\")\n    };\n  }\n  const asyncData = { ...nuxtApp._asyncData[key] };\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxtApp._asyncDataPromises[key]) {\n      if (isDefer(opts.dedupe ?? options.dedupe)) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    if ((opts._initial || nuxtApp.isHydrating && opts._initial !== false) && hasCachedData()) {\n      return Promise.resolve(options.getCachedData(key, nuxtApp));\n    }\n    asyncData.pending.value = true;\n    asyncData.status.value = \"pending\";\n    const promise = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxtApp));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then(async (_result) => {\n      if (promise.cancelled) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      let result = _result;\n      if (options.transform) {\n        result = await options.transform(_result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      nuxtApp.payload.data[key] = result;\n      asyncData.data.value = result;\n      asyncData.error.value = null;\n      asyncData.status.value = \"success\";\n    }).catch((error) => {\n      if (promise.cancelled) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      asyncData.error.value = createError(error);\n      asyncData.data.value = unref(options.default());\n      asyncData.status.value = \"error\";\n    }).finally(() => {\n      if (promise.cancelled) {\n        return;\n      }\n      asyncData.pending.value = false;\n      delete nuxtApp._asyncDataPromises[key];\n    });\n    nuxtApp._asyncDataPromises[key] = promise;\n    return nuxtApp._asyncDataPromises[key];\n  };\n  asyncData.clear = () => clearNuxtDataByKey(nuxtApp, key);\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    const instance = getCurrentInstance();\n    if (import.meta.dev && !nuxtApp.isHydrating && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${options._functionName || \"useAsyncData\"}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      if (instance) {\n        onBeforeMount(() => {\n          cbs.forEach((cb) => {\n            cb();\n          });\n          cbs.splice(0, cbs.length);\n        });\n        onUnmounted(() => cbs.splice(0, cbs.length));\n      }\n    }\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || hasCachedData())) {\n      asyncData.pending.value = false;\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    if (options.watch) {\n      watch(options.watch, () => asyncData.refresh());\n    }\n    const off = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n      if (!keys || keys.includes(key)) {\n        await asyncData.refresh();\n      }\n    });\n    if (instance) {\n      onUnmounted(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev && import.meta.client) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = null;\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = null;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = void 0;\n    nuxtApp._asyncData[key].error.value = null;\n    nuxtApp._asyncData[key].pending.value = false;\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    nuxtApp._asyncDataPromises[key].cancelled = true;\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n","import { computed, reactive, toValue } from \"vue\";\nimport { hash } from \"ohash\";\nimport { useRequestFetch } from \"./ssr.js\";\nimport { useAsyncData } from \"./asyncData.js\";\nimport { fetchDefaults } from \"#build/nuxt.config.mjs\";\nexport function useFetch(request, arg1, arg2) {\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  const _request = computed(() => toValue(request));\n  const _key = opts.key || hash([autoKey, typeof _request.value === \"string\" ? _request.value : \"\", ...generateOptionSegments(opts)]);\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useFetch] key must be a string: \" + _key);\n  }\n  if (!request) {\n    throw new Error(\"[nuxt] [useFetch] request is missing.\");\n  }\n  const key = _key === autoKey ? \"$f\" + _key : _key;\n  if (!opts.baseURL && typeof _request.value === \"string\" && (_request.value[0] === \"/\" && _request.value[1] === \"/\")) {\n    throw new Error('[nuxt] [useFetch] the request URL must not start with \"//\".');\n  }\n  const {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    watch,\n    immediate,\n    getCachedData,\n    deep,\n    dedupe,\n    ...fetchOptions\n  } = opts;\n  const _fetchOptions = reactive({\n    ...fetchDefaults,\n    ...fetchOptions,\n    cache: typeof opts.cache === \"boolean\" ? void 0 : opts.cache\n  });\n  const _asyncDataOptions = {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    immediate,\n    getCachedData,\n    deep,\n    dedupe,\n    watch: watch === false ? [] : [_fetchOptions, _request, ...watch || []]\n  };\n  if (import.meta.dev && import.meta.client) {\n    _asyncDataOptions._functionName = opts._functionName || \"useFetch\";\n  }\n  let controller;\n  const asyncData = useAsyncData(key, () => {\n    controller?.abort?.();\n    controller = typeof AbortController !== \"undefined\" ? new AbortController() : {};\n    const timeoutLength = toValue(opts.timeout);\n    if (timeoutLength) {\n      setTimeout(() => controller.abort(), timeoutLength);\n    }\n    let _$fetch = opts.$fetch || globalThis.$fetch;\n    if (import.meta.server && !opts.$fetch) {\n      const isLocalFetch = typeof _request.value === \"string\" && _request.value[0] === \"/\" && (!toValue(opts.baseURL) || toValue(opts.baseURL)[0] === \"/\");\n      if (isLocalFetch) {\n        _$fetch = useRequestFetch();\n      }\n    }\n    return _$fetch(_request.value, { signal: controller.signal, ..._fetchOptions });\n  }, _asyncDataOptions);\n  return asyncData;\n}\nexport function useLazyFetch(request, arg1, arg2) {\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  if (import.meta.dev && import.meta.client) {\n    opts._functionName ||= \"useLazyFetch\";\n  }\n  return useFetch(\n    request,\n    {\n      ...opts,\n      lazy: true\n    },\n    // @ts-expect-error we pass an extra argument with the resolved auto-key to prevent another from being injected\n    autoKey\n  );\n}\nfunction generateOptionSegments(opts) {\n  const segments = [\n    toValue(opts.method)?.toUpperCase() || \"GET\",\n    toValue(opts.baseURL)\n  ];\n  for (const _obj of [opts.params || opts.query]) {\n    const obj = toValue(_obj);\n    if (!obj) {\n      continue;\n    }\n    const unwrapped = {};\n    for (const [key, value] of Object.entries(obj)) {\n      unwrapped[toValue(key)] = toValue(value);\n    }\n    segments.push(unwrapped);\n  }\n  return segments;\n}\n"],"names":["pick"],"mappings":"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","x_google_ignoreList":[0,1]}